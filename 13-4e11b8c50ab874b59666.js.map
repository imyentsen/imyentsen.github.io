{"version":3,"sources":["webpack:///./node_modules/pts/dist/es2015/Util.js","webpack:///./node_modules/pts/dist/es2015/LinearAlgebra.js","webpack:///./node_modules/pts/dist/es2015/Op.js","webpack:///./node_modules/pts/dist/es2015/Num.js","webpack:///./node_modules/pts/dist/es2015/Pt.js","webpack:///./node_modules/pts/dist/es2015/UI.js","webpack:///./node_modules/pts/dist/es2015/Space.js","webpack:///./node_modules/pts/dist/es2015/Form.js","webpack:///./node_modules/pts/dist/es2015/Typography.js","webpack:///./node_modules/pts/dist/es2015/Canvas.js","webpack:///./node_modules/pts/dist/es2015/Create.js","webpack:///./node_modules/pts/dist/es2015/Color.js","webpack:///./node_modules/pts/dist/es2015/Dom.js","webpack:///./node_modules/pts/dist/es2015/Svg.js","webpack:///./node_modules/pts/dist/es2015/_module.js","webpack:///./node_modules/core-js/modules/es6.function.name.js"],"names":["Const","xy","yz","xz","xyz","horizontal","vertical","identical","right","bottom_right","bottom","bottom_left","left","top_left","top","top_right","epsilon","max","Number","MAX_VALUE","min","MIN_VALUE","pi","Math","PI","two_pi","half_pi","quarter_pi","one_degree","rad_to_deg","deg_to_rad","gravity","newton","gaussian","Util_Util","[object Object]","lv","_warnLevel","args","length","pos","isArray","Array","ArrayBuffer","isView","prototype","slice","call","a","p","i","push","message","defaultReturn","warnLevel","Error","range","start","floor","random","pts","size","stride","loopBack","st","chunks","g","concat","flattenAsGroup","arr","Pt_Group","apply","b","op","result","len","k","lenB","arrays","z","callback","c","fn","step","temp","url","request","XMLHttpRequest","open","onload","status","responseText","onerror","send","LinearAlgebra_Vec","toString","d","Pt_Pt","sqrt","dot","magnitude","m","undefined","divide","map","abs","ceil","round","index","value","s","LinearAlgebra_Mat","isNum","$add","transposed","elementwise","ai","alen","$multiply","transpose","make","bi","blen","defaultValue","useLongest","ps","reduce","zipSlice","zip","pt","x","y","cosA","sinA","tanX","tanY","sx","sy","at","scale2DMatrix","rotate2DMatrix","shear2DMatrix","p1","p2","intercept","Op_Line","yi","ang2","atan","slope","cos","sin","_errorLength","obj","param","warn","_errorOutofBound","anchor","angle","toAngle","xi","line","p3","threshold","to","$subtract","$cross","equals","magnitudeSq","asProjection","proj","$project","perpendicularFromPt","la","lb","pa","pb","y1","px","py","intersectRay2D","Num_Geom","withinBound","ray","lineOrRay","poly","sourceIsRay","intersectLineWithRay2D","intersectLine2D","next","lines1","lines2","isRay","group","lenk","_ip","gridPt","t","subtract","intersectGridWithRay2D","gg","rect","box","boundingBox","fromPtArray","Op_Rectangle","hasIntersectRect2D","intersectLines2D","sides","num","interpolate","cropAsCircle","ls","unit","multiply","fromCenter","sideIdx","graphic","atTail","perpendicular","add","$min","$max","topLeft","widthOrSize","height","fromTopLeft","center","half","within","Op_Circle","fromRect","enclose","maxValue","minValue","p0","corners","rects","merged","flatten","_center","ratio","asRows","mid","Num_Num","lerp","rect1","rect2","resetBoundingBox","r","Op_Triangle","circumcircle","incircle","radius","f","disc","discSqrt","t1","t2","circle","dv","dr2","dr","ar","br","ar2","br2","clone","h","ang","inc","toTriangle","fromCircle","Op_Polygon","midpoints","opp","oppositeSide","altitude","bisector","incenter","area","perimeter","total","md","medial","circumcenter","centroid","idx","closePath","sp","split","lines","gs","adjacentSides","mag","segments","det","sorted","sort","dq","bot","hull","originIndex","_near","_item","unitAxis","n","poly1","poly2","projectAxis","ln","lineAt","info","which","dist","normal","edge","vertex","minDist","MAX_SAFE_INTEGER","axis","_axisOverlap","plen","b1","b2","c1","c2","smallest","lp","ins","intersectPolygon2D","polys","boxes","unshift","val","sum","currA","currB","targetA","targetB","normalizeValue","boundValue","radian","minPt","maxPt","average","ptOrIndex","direction","method","boundPt1","boundPt2","bounds","da","db","$cross2D","scale","scs","lenP","rotateAt2DMatrix","$take","transform2D","shearAt2DMatrix","tanx","tan","tany","mat","reflectAt2DMatrix","Float64Array","table","rad","boundAngle","toDegree","Float32Array","super","getArgs","dimensions","randomize","fill","id","this","_id","w","anchorFromPt","change","self","params","fns","_ops","toArray","cross2D","cross","atan2","boundRadian","rotate2D","shear2D","reflect2D","join","p4","q1","q2","q3","q4","list","from","chunkSize","splice","count","pts_per_segment","clamp","chunk","tc","moveBy","dim","desc","ptFn","forEachPt","Bound","_size","_topLeft","_bottomRight","_inited","init","width","_updateSize","_updateCenter","_updatePosFromTop","_updatePosFromCenter","bottomRight","depth","inited","UIShape","rectangle","polygon","polyline","UIPointerActions","up","down","move","drag","uidrag","drop","over","out","enter","leave","all","UI_UI","shape","states","_holds","_group","fromArray","_shape","_counter","_states","_actions","ui","key","_addHandler","_removeHandler","_within","indexOf","_trigger","uis","listen","hasIntersectPoint","target","type","Space_Space","bound","_time","prev","diff","end","players","playerCount","_animID","_pause","_refresh","_pointer","_isReady","_playing","player","animate","pid","animateID","resize","time","requestAnimationFrame","play","bind","playItems","err","cancelAnimationFrame","clear","toggle","duration","stop","context","_renderFunc","customRendering","isPlaying","outerBound","innerBound","Space_MultiTouchSpace","arguments","_pressed","_dragged","_hasMouse","_hasTouch","pointer","evt","_canvas","addEventListener","removeEventListener","_bind","bindCanvas","_mouseDown","_mouseUp","_mouseOver","_mouseOut","_mouseMove","unbindCanvas","_touchMove","ts","item","pageX","pageY","MouseEvent","hasOwnProperty","v","action","changedTouches","touch","_mouseAction","preventDefault","Form_Form","_ready","ready","required","VisualForm","_filled","_stroked","_font","Font","filled","stroked","currentFont","groups","rest","stroke","linejoin","linecap","point","_multiple","face","weight","style","lineHeight","Typography_Typography","samples","distribution","avg","str","tail","trim","substr","byHeight","nh","defaultSize","Canvas_CanvasSpace","elem","_pixelScale","_autoResize","_bgcolor","_offscreen","_initialResize","_selector","Element","document","querySelector","nodeName","toLowerCase","_container","_createElement","appendChild","parentElement","body","setTimeout","_ctx","getContext","createElement","setAttribute","_resizeHandler","dispatchEvent","Event","opt","bgcolor","autoResize","retina","r1","window","devicePixelRatio","r2","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","offscreen","_offCanvas","_offCtx","auto","translate","render","playOnce","getBoundingClientRect","fromBoundingRect","pageXOffset","pageYOffset","background","bg","pixelScale","hasOffscreen","offscreenCtx","offscreenCanvas","Canvas_CanvasForm","element","parent","ctx","lastColor","fillStyle","fillRect","clearRect","save","restore","space","_style","strokeStyle","lineWidth","lineJoin","lineCap","_space","font","off","clearOffscreen","offset","drawImage","sizeOrFont","family","_estimateTextWidth","fontWidthEstimate","estimate","textWidthEstimator","measureText","truncate","getTextWidth","textAlign","_paint","beginPath","arc","startAngle","endAngle","cc","halfsize","x1","x2","y2","moveTo","lineTo","square","img","orig","original","image","txt","maxWidth","fillText","text","verticalAlign","overrideBaseline","textBaseline","_textTruncate","_textAlign","crop","lstep","nextLine","sub","buffer","newln","dt","lastIndexOf","lsize","lbox","lpad","alignment","baseline","Create_Create","subpoints","columns","rows","orientation","$divide","dx","dy","seed","np","Create_Noise","initNoise","Create_Delaunay","grad3","permTable","perm","_n","j","n00","n01","n10","n11","_fade","tx","_mesh","triangleOnly","indices","_superTriangle","opened","_circum","closed","tris","edges","circum","triangle","_dedupe","o","_cache","vs","neighborPts","cs","sortEdges","dmax","tri","_triangle","Color_Color","_mode","_isNorm","hex","alpha","substring","hexVal","parseInt","toMode","mode","ranges","rgb","rgba","convert","fname","toUpperCase","l","u","normalized","toNorm","mapToRange","normalize","format","_hex","normalizedInput","normalizedOutput","$normalize","hsl","q","sc","hsb","XYZtoLAB","RGBtoXYZ","lab","XYZtoRGB","LABtoXYZ","LABtoLCH","RGBtoLAB","lch","LABtoRGB","LCHtoLAB","XYZtoLUV","luv","LUVtoXYZ","pow","D65","cy","nnn","refU","refV","L","cubeY","toRadian","Dom_DOMSpace","_css","appendTo","refresh","styles","innerHTML","backgroundColor","update","data","HTMLSpace","Dom_HTMLForm","name","autoClass","querySelectorAll","scopeID","forEach","el","parentNode","removeChild","remove","removeAll","groupID","groupCount","currentID","currentClass","border-color","color","border-width","border-radius","border-style","position","fontSize","fontFamily","styleTo","group_id","nextID","updateScope","domID","setAttr","htmlElement","getID","class","rectStyle","_checkSize","textContent","Svg_SVGSpace","svgElement","Svg_SVGForm","viewBox","xmlns","version","createElementNS","stroke-width","stroke-linejoin","stroke-linecap","cx","largeArc","sweep","_poly","points","pointer-events","__webpack_require__","__webpack_exports__","dP","FProto","Function","nameRE","configurable","get","match","e"],"mappings":"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","file":"13-4e11b8c50ab874b59666.js","sourcesContent":["/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Group } from \"./Pt\";\nexport const Const = {\n    xy: \"xy\",\n    yz: \"yz\",\n    xz: \"xz\",\n    xyz: \"xyz\",\n    horizontal: 0,\n    vertical: 1,\n    identical: 0,\n    right: 4,\n    bottom_right: 5,\n    bottom: 6,\n    bottom_left: 7,\n    left: 8,\n    top_left: 1,\n    top: 2,\n    top_right: 3,\n    epsilon: 0.0001,\n    max: Number.MAX_VALUE,\n    min: Number.MIN_VALUE,\n    pi: Math.PI,\n    two_pi: 6.283185307179586,\n    half_pi: 1.5707963267948966,\n    quarter_pi: 0.7853981633974483,\n    one_degree: 0.017453292519943295,\n    rad_to_deg: 57.29577951308232,\n    deg_to_rad: 0.017453292519943295,\n    gravity: 9.81,\n    newton: 0.10197,\n    gaussian: 0.3989422804014327\n};\nexport class Util {\n    static warnLevel(lv) {\n        if (lv) {\n            Util._warnLevel = lv;\n        }\n        return Util._warnLevel;\n    }\n    static getArgs(args) {\n        if (args.length < 1)\n            return [];\n        let pos = [];\n        let isArray = Array.isArray(args[0]) || ArrayBuffer.isView(args[0]);\n        if (typeof args[0] === 'number') {\n            pos = Array.prototype.slice.call(args);\n        }\n        else if (typeof args[0] === 'object' && !isArray) {\n            let a = [\"x\", \"y\", \"z\", \"w\"];\n            let p = args[0];\n            for (let i = 0; i < a.length; i++) {\n                if ((p.length && i >= p.length) || !(a[i] in p))\n                    break;\n                pos.push(p[a[i]]);\n            }\n        }\n        else if (isArray) {\n            pos = [].slice.call(args[0]);\n        }\n        return pos;\n    }\n    static warn(message = \"error\", defaultReturn = undefined) {\n        if (Util.warnLevel() == \"error\") {\n            throw new Error(message);\n        }\n        else if (Util.warnLevel() == \"warn\") {\n            console.warn(message);\n        }\n        return defaultReturn;\n    }\n    static randomInt(range, start = 0) {\n        return Math.floor(Math.random() * range) + start;\n    }\n    static split(pts, size, stride, loopBack = false) {\n        let st = stride || size;\n        let chunks = [];\n        for (let i = 0; i < pts.length; i++) {\n            if (i * st + size > pts.length) {\n                if (loopBack) {\n                    let g = pts.slice(i * st);\n                    g = g.concat(pts.slice(0, (i * st + size) % size));\n                    chunks.push(g);\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                chunks.push(pts.slice(i * st, i * st + size));\n            }\n        }\n        return chunks;\n    }\n    static flatten(pts, flattenAsGroup = true) {\n        let arr = (flattenAsGroup) ? new Group() : new Array();\n        return arr.concat.apply(arr, pts);\n    }\n    static combine(a, b, op) {\n        let result = [];\n        for (let i = 0, len = a.length; i < len; i++) {\n            for (let k = 0, lenB = b.length; k < lenB; k++) {\n                result.push(op(a[i], b[k]));\n            }\n        }\n        return result;\n    }\n    static zip(arrays) {\n        let z = [];\n        for (let i = 0, len = arrays[0].length; i < len; i++) {\n            let p = [];\n            for (let k = 0; k < arrays.length; k++) {\n                p.push(arrays[k][i]);\n            }\n            z.push(p);\n        }\n        return z;\n    }\n    static stepper(max, min = 0, stride = 1, callback) {\n        let c = min;\n        return function () {\n            c += stride;\n            if (c >= max) {\n                c = min + (c - max);\n            }\n            if (callback)\n                callback(c);\n            return c;\n        };\n    }\n    static forRange(fn, range, start = 0, step = 1) {\n        let temp = [];\n        for (let i = start, len = range; i < len; i += step) {\n            temp[i] = fn(i);\n        }\n        return temp;\n    }\n    static load(url, callback) {\n        var request = new XMLHttpRequest();\n        request.open('GET', url, true);\n        request.onload = function () {\n            if (request.status >= 200 && request.status < 400) {\n                callback(request.responseText, true);\n            }\n            else {\n                callback(`Server error (${request.status}) when loading \"${url}\"`, false);\n            }\n        };\n        request.onerror = function () {\n            callback(`Unknown network error`, false);\n        };\n        request.send();\n    }\n}\nUtil._warnLevel = \"mute\";\n//# sourceMappingURL=Util.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Line } from \"./Op\";\nexport class Vec {\n    static add(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b[i] || 0;\n        }\n        return a;\n    }\n    static subtract(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b[i] || 0;\n        }\n        return a;\n    }\n    static multiply(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${a.toString()} multiply-with ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b[i];\n        }\n        return a;\n    }\n    static divide(a, b) {\n        if (typeof b == \"number\") {\n            if (b === 0)\n                throw new Error(\"Cannot divide by zero\");\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${a.toString()} divide-by ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b[i];\n        }\n        return a;\n    }\n    static dot(a, b) {\n        if (a.length != b.length)\n            throw new Error(\"Array lengths don't match\");\n        let d = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            d += a[i] * b[i];\n        }\n        return d;\n    }\n    static cross2D(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n    }\n    static cross(a, b) {\n        return new Pt((a[1] * b[2] - a[2] * b[1]), (a[2] * b[0] - a[0] * b[2]), (a[0] * b[1] - a[1] * b[0]));\n    }\n    static magnitude(a) {\n        return Math.sqrt(Vec.dot(a, a));\n    }\n    static unit(a, magnitude = undefined) {\n        let m = (magnitude === undefined) ? Vec.magnitude(a) : magnitude;\n        if (m === 0)\n            throw new Error(\"Cannot calculate unit vector because magnitude is 0\");\n        return Vec.divide(a, m);\n    }\n    static abs(a) {\n        return Vec.map(a, Math.abs);\n    }\n    static floor(a) {\n        return Vec.map(a, Math.floor);\n    }\n    static ceil(a) {\n        return Vec.map(a, Math.ceil);\n    }\n    static round(a) {\n        return Vec.map(a, Math.round);\n    }\n    static max(a) {\n        let m = Number.MIN_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.max(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static min(a) {\n        let m = Number.MAX_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.min(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static sum(a) {\n        let s = 0;\n        for (let i = 0, len = a.length; i < len; i++)\n            s += a[i];\n        return s;\n    }\n    static map(a, fn) {\n        for (let i = 0, len = a.length; i < len; i++) {\n            a[i] = fn(a[i], i, a);\n        }\n        return a;\n    }\n}\nexport class Mat {\n    static add(a, b) {\n        if (typeof b != \"number\") {\n            if (a[0].length != b[0].length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n            if (a.length != b.length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n        }\n        let g = new Group();\n        let isNum = typeof b == \"number\";\n        for (let i = 0, len = a.length; i < len; i++) {\n            g.push(a[i].$add((isNum) ? b : b[i]));\n        }\n        return g;\n    }\n    static multiply(a, b, transposed = false, elementwise = false) {\n        let g = new Group();\n        if (typeof b != \"number\") {\n            if (elementwise) {\n                if (a.length != b.length)\n                    throw new Error(\"Cannot multiply matrix element-wise because the matrices' sizes don't match.\");\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    g.push(a[ai].$multiply(b[ai]));\n                }\n            }\n            else {\n                if (!transposed && a[0].length != b.length)\n                    throw new Error(\"Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.\");\n                if (transposed && a[0].length != b[0].length)\n                    throw new Error(\"Cannot multiply matrix if transposed and the columns in both matrices don't match.\");\n                if (!transposed)\n                    b = Mat.transpose(b);\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    let p = Pt.make(b.length, 0);\n                    for (let bi = 0, blen = b.length; bi < blen; bi++) {\n                        p[bi] = Vec.dot(a[ai], b[bi]);\n                    }\n                    g.push(p);\n                }\n            }\n        }\n        else {\n            for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                g.push(a[ai].$multiply(b));\n            }\n        }\n        return g;\n    }\n    static zipSlice(g, index, defaultValue = false) {\n        let z = [];\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (g[i].length - 1 < index && defaultValue === false)\n                throw `Index ${index} is out of bounds`;\n            z.push(g[i][index] || defaultValue);\n        }\n        return new Pt(z);\n    }\n    static zip(g, defaultValue = false, useLongest = false) {\n        let ps = new Group();\n        let len = (useLongest) ? g.reduce((a, b) => Math.max(a, b.length), 0) : g[0].length;\n        for (let i = 0; i < len; i++) {\n            ps.push(Mat.zipSlice(g, i, defaultValue));\n        }\n        return ps;\n    }\n    static transpose(g, defaultValue = false, useLongest = false) {\n        return Mat.zip(g, defaultValue, useLongest);\n    }\n    static transform2D(pt, m) {\n        let x = pt[0] * m[0][0] + pt[1] * m[1][0] + m[2][0];\n        let y = pt[0] * m[0][1] + pt[1] * m[1][1] + m[2][1];\n        return new Pt(x, y);\n    }\n    static scale2DMatrix(x, y) {\n        return new Group(new Pt(x, 0, 0), new Pt(0, y, 0), new Pt(0, 0, 1));\n    }\n    static rotate2DMatrix(cosA, sinA) {\n        return new Group(new Pt(cosA, sinA, 0), new Pt(-sinA, cosA, 0), new Pt(0, 0, 1));\n    }\n    static shear2DMatrix(tanX, tanY) {\n        return new Group(new Pt(1, tanX, 0), new Pt(tanY, 1, 0), new Pt(0, 0, 1));\n    }\n    static translate2DMatrix(x, y) {\n        return new Group(new Pt(1, 0, 0), new Pt(0, 1, 0), new Pt(x, y, 1));\n    }\n    static scaleAt2DMatrix(sx, sy, at) {\n        let m = Mat.scale2DMatrix(sx, sy);\n        m[2][0] = -at[0] * sx + at[0];\n        m[2][1] = -at[1] * sy + at[1];\n        return m;\n    }\n    static rotateAt2DMatrix(cosA, sinA, at) {\n        let m = Mat.rotate2DMatrix(cosA, sinA);\n        m[2][0] = at[0] * (1 - cosA) + at[1] * sinA;\n        m[2][1] = at[1] * (1 - cosA) - at[0] * sinA;\n        return m;\n    }\n    static shearAt2DMatrix(tanX, tanY, at) {\n        let m = Mat.shear2DMatrix(tanX, tanY);\n        m[2][0] = -at[1] * tanY;\n        m[2][1] = -at[0] * tanX;\n        return m;\n    }\n    static reflectAt2DMatrix(p1, p2) {\n        let intercept = Line.intercept(p1, p2);\n        if (intercept == undefined) {\n            return [\n                new Pt([-1, 0, 0]),\n                new Pt([0, 1, 0]),\n                new Pt([p1[0] + p2[0], 0, 1])\n            ];\n        }\n        else {\n            let yi = intercept.yi;\n            let ang2 = Math.atan(intercept.slope) * 2;\n            let cosA = Math.cos(ang2);\n            let sinA = Math.sin(ang2);\n            return [\n                new Pt([cosA, sinA, 0]),\n                new Pt([sinA, -cosA, 0]),\n                new Pt([-yi * sinA, yi + yi * cosA, 1])\n            ];\n        }\n    }\n}\n//# sourceMappingURL=LinearAlgebra.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\nlet _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\nlet _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\nexport class Line {\n    static fromAngle(anchor, angle, magnitude) {\n        let g = new Group(new Pt(anchor), new Pt(anchor));\n        g[1].toAngle(angle, magnitude, true);\n        return g;\n    }\n    static slope(p1, p2) {\n        return (p2[0] - p1[0] === 0) ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n    static intercept(p1, p2) {\n        if (p2[0] - p1[0] === 0) {\n            return undefined;\n        }\n        else {\n            let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n            let c = p1[1] - m * p1[0];\n            return { slope: m, yi: c, xi: (m === 0) ? undefined : -c / m };\n        }\n    }\n    static sideOfPt2D(line, pt) {\n        return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n    static collinear(p1, p2, p3, threshold = 0.01) {\n        let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n        let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n        return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n    }\n    static magnitude(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n    static magnitudeSq(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n    static perpendicularFromPt(line, pt, asProjection = false) {\n        if (line[0].equals(line[1]))\n            return undefined;\n        let a = line[0].$subtract(line[1]);\n        let b = line[1].$subtract(pt);\n        let proj = b.$subtract(a.$project(b));\n        return (asProjection) ? proj : proj.$add(pt);\n    }\n    static distanceFromPt(line, pt) {\n        return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n    static intersectRay2D(la, lb) {\n        let a = Line.intercept(la[0], la[1]);\n        let b = Line.intercept(lb[0], lb[1]);\n        let pa = la[0];\n        let pb = lb[0];\n        if (a == undefined) {\n            if (b == undefined)\n                return undefined;\n            let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n            return new Pt(pa[0], y1);\n        }\n        else {\n            if (b == undefined) {\n                let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n                return new Pt(pb[0], y1);\n            }\n            else if (b.slope != a.slope) {\n                let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n                let py = a.slope * (px - pa[0]) + pa[1];\n                return new Pt(px, py);\n            }\n            else {\n                if (a.yi == b.yi) {\n                    return new Pt(pa[0], pa[1]);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n    }\n    static intersectLine2D(la, lb) {\n        let pt = Line.intersectRay2D(la, lb);\n        return (pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1])) ? pt : undefined;\n    }\n    static intersectLineWithRay2D(line, ray) {\n        let pt = Line.intersectRay2D(line, ray);\n        return (pt && Geom.withinBound(pt, line[0], line[1])) ? pt : undefined;\n    }\n    static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n        let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        let pts = new Group();\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let next = (i === len - 1) ? 0 : i + 1;\n            let d = fn([poly[i], poly[next]], lineOrRay);\n            if (d)\n                pts.push(d);\n        }\n        return (pts.length > 0) ? pts : undefined;\n    }\n    static intersectLines2D(lines1, lines2, isRay = false) {\n        let group = new Group();\n        let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        for (let i = 0, len = lines1.length; i < len; i++) {\n            for (let k = 0, lenk = lines2.length; k < lenk; k++) {\n                let _ip = fn(lines1[i], lines2[k]);\n                if (_ip)\n                    group.push(_ip);\n            }\n        }\n        return group;\n    }\n    static intersectGridWithRay2D(ray, gridPt) {\n        let t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n        let g = new Group();\n        if (t && t.xi)\n            g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n        if (t && t.yi)\n            g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n        return g;\n    }\n    static intersectGridWithLine2D(line, gridPt) {\n        let g = Line.intersectGridWithRay2D(line, gridPt);\n        let gg = new Group();\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (Geom.withinBound(g[i], line[0], line[1]))\n                gg.push(g[i]);\n        }\n        return gg;\n    }\n    static intersectRect2D(line, rect) {\n        let box = Geom.boundingBox(Group.fromPtArray(line));\n        if (!Rectangle.hasIntersectRect2D(box, rect))\n            return new Group();\n        return Line.intersectLines2D([line], Rectangle.sides(rect));\n    }\n    static subpoints(line, num) {\n        let pts = new Group();\n        for (let i = 1; i <= num; i++) {\n            pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n        }\n        return pts;\n    }\n    static crop(line, size, index = 0, cropAsCircle = true) {\n        let tdx = (index === 0) ? 1 : 0;\n        let ls = line[tdx].$subtract(line[index]);\n        if (ls[0] === 0 || size[0] === 0)\n            return line[index];\n        if (cropAsCircle) {\n            let d = ls.unit().multiply(size[1]);\n            return line[index].$add(d);\n        }\n        else {\n            let rect = Rectangle.fromCenter(line[index], size);\n            let sides = Rectangle.sides(rect);\n            let sideIdx = 0;\n            if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n                sideIdx = (ls[1] < 0) ? 0 : 2;\n            }\n            else {\n                sideIdx = (ls[0] < 0) ? 3 : 1;\n            }\n            return Line.intersectRay2D(sides[sideIdx], line);\n        }\n    }\n    static marker(line, size, graphic = (\"arrow\" || \"line\"), atTail = true) {\n        let h = atTail ? 0 : 1;\n        let t = atTail ? 1 : 0;\n        let unit = line[h].$subtract(line[t]);\n        if (unit.magnitudeSq() === 0)\n            return new Group();\n        unit.unit();\n        let ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n        if (graphic == \"arrow\") {\n            ps.add(unit.$multiply(size[1]));\n            return new Group(line[t], ps[0], ps[1]);\n        }\n        else {\n            return new Group(ps[0], ps[1]);\n        }\n    }\n    static toRect(line) {\n        return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n}\nexport class Rectangle {\n    static from(topLeft, widthOrSize, height) {\n        return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n    static fromTopLeft(topLeft, widthOrSize, height) {\n        let size = (typeof widthOrSize == \"number\") ? [widthOrSize, (height || widthOrSize)] : widthOrSize;\n        return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n    }\n    static fromCenter(center, widthOrSize, height) {\n        let half = (typeof widthOrSize == \"number\") ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n        return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n    }\n    static toCircle(pts, within = true) {\n        return Circle.fromRect(pts, within);\n    }\n    static toSquare(pts, enclose = false) {\n        let s = Rectangle.size(pts);\n        let m = (enclose) ? s.maxValue().value : s.minValue().value;\n        return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n    static size(pts) {\n        return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n    static center(pts) {\n        let min = pts[0].$min(pts[1]);\n        let max = pts[0].$max(pts[1]);\n        return min.add(max.$subtract(min).divide(2));\n    }\n    static corners(rect) {\n        let p0 = rect[0].$min(rect[1]);\n        let p2 = rect[0].$max(rect[1]);\n        return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n    }\n    static sides(rect) {\n        let [p0, p1, p2, p3] = Rectangle.corners(rect);\n        return [\n            new Group(p0, p1), new Group(p1, p2),\n            new Group(p2, p3), new Group(p3, p0)\n        ];\n    }\n    static boundingBox(rects) {\n        let merged = Util.flatten(rects, false);\n        let min = Pt.make(2, Number.MAX_VALUE);\n        let max = Pt.make(2, Number.MIN_VALUE);\n        for (let i = 0, len = merged.length; i < len; i++) {\n            for (let k = 0; k < 2; k++) {\n                min[k] = Math.min(min[k], merged[i][k]);\n                max[k] = Math.max(max[k], merged[i][k]);\n            }\n        }\n        return new Group(min, max);\n    }\n    static polygon(rect) {\n        return Rectangle.corners(rect);\n    }\n    static quadrants(rect, center) {\n        let corners = Rectangle.corners(rect);\n        let _center = (center != undefined) ? new Pt(center) : Rectangle.center(rect);\n        return corners.map((c) => new Group(c, _center).boundingBox());\n    }\n    static halves(rect, ratio = 0.5, asRows = false) {\n        let min = rect[0].$min(rect[1]);\n        let max = rect[0].$max(rect[1]);\n        let mid = (asRows) ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n        return (asRows)\n            ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)]\n            : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n    }\n    static withinBound(rect, pt) {\n        return Geom.withinBound(pt, rect[0], rect[1]);\n    }\n    static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n        if (resetBoundingBox) {\n            rect1 = Geom.boundingBox(rect1);\n            rect2 = Geom.boundingBox(rect2);\n        }\n        if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0])\n            return false;\n        if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1])\n            return false;\n        return true;\n    }\n    static intersectRect2D(rect1, rect2) {\n        if (!Rectangle.hasIntersectRect2D(rect1, rect2))\n            return new Group();\n        return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n    }\n}\nexport class Circle {\n    static fromRect(pts, enclose = false) {\n        let r = 0;\n        let min = r = Rectangle.size(pts).minValue().value / 2;\n        if (enclose) {\n            let max = Rectangle.size(pts).maxValue().value / 2;\n            r = Math.sqrt(min * min + max * max);\n        }\n        else {\n            r = min;\n        }\n        return new Group(Rectangle.center(pts), new Pt(r, r));\n    }\n    static fromTriangle(pts, enclose = false) {\n        if (enclose) {\n            return Triangle.circumcircle(pts);\n        }\n        else {\n            return Triangle.incircle(pts);\n        }\n    }\n    static fromCenter(pt, radius) {\n        return new Group(new Pt(pt), new Pt(radius, radius));\n    }\n    static withinBound(pts, pt, threshold = 0) {\n        let d = pts[0].$subtract(pt);\n        return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n    static intersectRay2D(pts, ray) {\n        let d = ray[0].$subtract(ray[1]);\n        let f = pts[0].$subtract(ray[0]);\n        let a = d.dot(d);\n        let b = f.dot(d);\n        let c = f.dot(f) - pts[1].x * pts[1].x;\n        let p = b / a;\n        let q = c / a;\n        let disc = p * p - q;\n        if (disc < 0) {\n            return new Group();\n        }\n        else {\n            let discSqrt = Math.sqrt(disc);\n            let t1 = -p + discSqrt;\n            let p1 = ray[0].$subtract(d.$multiply(t1));\n            if (disc === 0)\n                return new Group(p1);\n            let t2 = -p - discSqrt;\n            let p2 = ray[0].$subtract(d.$multiply(t2));\n            return new Group(p1, p2);\n        }\n    }\n    static intersectLine2D(pts, line) {\n        let ps = Circle.intersectRay2D(pts, line);\n        let g = new Group();\n        if (ps.length > 0) {\n            for (let i = 0, len = ps.length; i < len; i++) {\n                if (Rectangle.withinBound(line, ps[i]))\n                    g.push(ps[i]);\n            }\n        }\n        return g;\n    }\n    static intersectCircle2D(pts, circle) {\n        let dv = circle[0].$subtract(pts[0]);\n        let dr2 = dv.magnitudeSq();\n        let dr = Math.sqrt(dr2);\n        let ar = pts[1].x;\n        let br = circle[1].x;\n        let ar2 = ar * ar;\n        let br2 = br * br;\n        if (dr > ar + br) {\n            return new Group();\n        }\n        else if (dr < Math.abs(ar - br)) {\n            return new Group(pts[0].clone());\n        }\n        else {\n            let a = (ar2 - br2 + dr2) / (2 * dr);\n            let h = Math.sqrt(ar2 - a * a);\n            let p = dv.$multiply(a / dr).add(pts[0]);\n            return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n        }\n    }\n    static intersectRect2D(pts, rect) {\n        let sides = Rectangle.sides(rect);\n        let g = [];\n        for (let i = 0, len = sides.length; i < len; i++) {\n            let ps = Circle.intersectLine2D(pts, sides[i]);\n            if (ps.length > 0)\n                g.push(ps);\n        }\n        return Util.flatten(g);\n    }\n    static toRect(pts, within = false) {\n        let r = pts[1][0];\n        if (within) {\n            let half = Math.sqrt(r * r) / 2;\n            return new Group(pts[0].$subtract(half), pts[0].$add(half));\n        }\n        else {\n            return new Group(pts[0].$subtract(r), pts[0].$add(r));\n        }\n    }\n    static toTriangle(pts, within = true) {\n        if (within) {\n            let ang = -Math.PI / 2;\n            let inc = Math.PI * 2 / 3;\n            let g = new Group();\n            for (let i = 0; i < 3; i++) {\n                g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n                ang += inc;\n            }\n            return g;\n        }\n        else {\n            return Triangle.fromCenter(pts[0], pts[1][0]);\n        }\n    }\n}\nexport class Triangle {\n    static fromRect(rect) {\n        let top = rect[0].$add(rect[1]).divide(2);\n        top.y = rect[0][1];\n        let left = rect[1].clone();\n        left.x = rect[0][0];\n        return new Group(top, rect[1].clone(), left);\n    }\n    static fromCircle(circle) {\n        return Circle.toTriangle(circle, true);\n    }\n    static fromCenter(pt, size) {\n        return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n    static medial(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        return Polygon.midpoints(pts, true);\n    }\n    static oppositeSide(pts, index) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (index === 0) {\n            return Group.fromPtArray([pts[1], pts[2]]);\n        }\n        else if (index === 1) {\n            return Group.fromPtArray([pts[0], pts[2]]);\n        }\n        else {\n            return Group.fromPtArray([pts[0], pts[1]]);\n        }\n    }\n    static altitude(pts, index) {\n        let opp = Triangle.oppositeSide(pts, index);\n        if (opp.length > 1) {\n            return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n        }\n        else {\n            return new Group();\n        }\n    }\n    static orthocenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Triangle.altitude(pts, 0);\n        let b = Triangle.altitude(pts, 1);\n        return Line.intersectRay2D(a, b);\n    }\n    static incenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Polygon.bisector(pts, 0).add(pts[0]);\n        let b = Polygon.bisector(pts, 1).add(pts[1]);\n        return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n    }\n    static incircle(pts, center) {\n        let c = (center) ? center : Triangle.incenter(pts);\n        let area = Polygon.area(pts);\n        let perim = Polygon.perimeter(pts, true);\n        let r = 2 * area / perim.total;\n        return Circle.fromCenter(c, r);\n    }\n    static circumcenter(pts) {\n        let md = Triangle.medial(pts);\n        let a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n        let b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n        return Line.intersectRay2D(a, b);\n    }\n    static circumcircle(pts, center) {\n        let c = (center) ? center : Triangle.circumcenter(pts);\n        let r = pts[0].$subtract(c).magnitude();\n        return Circle.fromCenter(c, r);\n    }\n}\nexport class Polygon {\n    static centroid(pts) {\n        return Geom.centroid(pts);\n    }\n    static rectangle(center, widthOrSize, height) {\n        return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n    }\n    static fromCenter(center, radius, sides) {\n        let g = new Group();\n        for (let i = 0; i < sides; i++) {\n            let ang = Math.PI * 2 * i / sides;\n            g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n        }\n        return g;\n    }\n    static lineAt(pts, idx) {\n        if (idx < 0 || idx >= pts.length)\n            throw new Error(\"index out of the Polygon's range\");\n        return new Group(pts[idx], (idx === pts.length - 1) ? pts[0] : pts[idx + 1]);\n    }\n    static lines(pts, closePath = true) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sp = Util.split(pts, 2, 1);\n        if (closePath)\n            sp.push(new Group(pts[pts.length - 1], pts[0]));\n        return sp.map((g) => g);\n    }\n    static midpoints(pts, closePath = false, t = 0.5) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sides = Polygon.lines(pts, closePath);\n        let mids = sides.map((s) => Geom.interpolate(s[0], s[1], t));\n        return mids;\n    }\n    static adjacentSides(pts, index, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        if (index < 0 || index >= pts.length)\n            return _errorOutofBound(new Group(), index);\n        let gs = [];\n        let left = index - 1;\n        if (closePath && left < 0)\n            left = pts.length - 1;\n        if (left >= 0)\n            gs.push(new Group(pts[index], pts[left]));\n        let right = index + 1;\n        if (closePath && right > pts.length - 1)\n            right = 0;\n        if (right <= pts.length - 1)\n            gs.push(new Group(pts[index], pts[right]));\n        return gs;\n    }\n    static bisector(pts, index) {\n        let sides = Polygon.adjacentSides(pts, index, true);\n        if (sides.length >= 2) {\n            let a = sides[0][1].$subtract(sides[0][0]).unit();\n            let b = sides[1][1].$subtract(sides[1][0]).unit();\n            return a.add(b).divide(2);\n        }\n        else {\n            return undefined;\n        }\n    }\n    static perimeter(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let lines = Polygon.lines(pts, closePath);\n        let mag = 0;\n        let p = Pt.make(lines.length, 0);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let m = Line.magnitude(lines[i]);\n            mag += m;\n            p[i] = m;\n        }\n        return {\n            total: mag,\n            segments: p\n        };\n    }\n    static area(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n        let area = 0;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i < pts.length - 1) {\n                area += det(pts[i], pts[i + 1]);\n            }\n            else {\n                area += det(pts[i], pts[0]);\n            }\n        }\n        return Math.abs(area / 2);\n    }\n    static convexHull(pts, sorted = false) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (!sorted) {\n            pts = pts.slice();\n            pts.sort((a, b) => a[0] - b[0]);\n        }\n        let left = (a, b, c) => {\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n        };\n        let dq = [];\n        let bot = pts.length - 2;\n        let top = bot + 3;\n        dq[bot] = pts[2];\n        dq[top] = pts[2];\n        if (left(pts[0], pts[1], pts[2])) {\n            dq[bot + 1] = pts[0];\n            dq[bot + 2] = pts[1];\n        }\n        else {\n            dq[bot + 1] = pts[1];\n            dq[bot + 2] = pts[0];\n        }\n        for (let i = 3, len = pts.length; i < len; i++) {\n            let pt = pts[i];\n            if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n                continue;\n            }\n            while (!left(dq[bot], dq[bot + 1], pt)) {\n                bot += 1;\n            }\n            bot -= 1;\n            dq[bot] = pt;\n            while (!left(dq[top - 1], dq[top], pt)) {\n                top -= 1;\n            }\n            top += 1;\n            dq[top] = pt;\n        }\n        let hull = new Group();\n        for (let h = 0; h < (top - bot); h++) {\n            hull.push(dq[bot + h]);\n        }\n        return hull;\n    }\n    static network(pts, originIndex = 0) {\n        let g = [];\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i != originIndex)\n                g.push(new Group(pts[originIndex], pts[i]));\n        }\n        return g;\n    }\n    static nearestPt(pts, pt) {\n        let _near = Number.MAX_VALUE;\n        let _item = -1;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let d = pts[i].$subtract(pt).magnitudeSq();\n            if (d < _near) {\n                _near = d;\n                _item = i;\n            }\n        }\n        return _item;\n    }\n    static projectAxis(poly, unitAxis) {\n        let dot = unitAxis.dot(poly[0]);\n        let d = new Pt(dot, dot);\n        for (let n = 1, len = poly.length; n < len; n++) {\n            dot = unitAxis.dot(poly[n]);\n            d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n        }\n        return d;\n    }\n    static _axisOverlap(poly1, poly2, unitAxis) {\n        let pa = Polygon.projectAxis(poly1, unitAxis);\n        let pb = Polygon.projectAxis(poly2, unitAxis);\n        return (pa[0] < pb[0]) ? pb[0] - pa[1] : pa[0] - pb[1];\n    }\n    static hasIntersectPoint(poly, pt) {\n        let c = false;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let ln = Polygon.lineAt(poly, i);\n            if (((ln[0][1] > pt[1]) != (ln[1][1] > pt[1])) &&\n                (pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0])) {\n                c = !c;\n            }\n        }\n        return c;\n    }\n    static hasIntersectCircle(poly, circle) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: null,\n            edge: null,\n            vertex: null,\n        };\n        let c = circle[0];\n        let r = circle[1][0];\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let edge = Polygon.lineAt(poly, i);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n            let dist = Polygon._axisOverlap(poly, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n                if (check) {\n                    info.edge = edge;\n                    info.normal = axis;\n                    minDist = Math.abs(dist);\n                    info.which = i;\n                }\n            }\n        }\n        if (!info.edge)\n            return null;\n        let dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        info.dist = minDist;\n        info.vertex = c;\n        return info;\n    }\n    static hasIntersectPolygon(poly1, poly2) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: new Pt(),\n            edge: new Group(),\n            vertex: new Pt()\n        };\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, plen = (poly1.length + poly2.length); i < plen; i++) {\n            let edge = (i < poly1.length) ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let dist = Polygon._axisOverlap(poly1, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                info.edge = edge;\n                info.normal = axis;\n                minDist = Math.abs(dist);\n                info.which = (i < poly1.length) ? 0 : 1;\n            }\n        }\n        info.dist = minDist;\n        let b1 = (info.which === 0) ? poly2 : poly1;\n        let b2 = (info.which === 0) ? poly1 : poly2;\n        let c1 = Polygon.centroid(b1);\n        let c2 = Polygon.centroid(b2);\n        let dir = c1.$subtract(c2).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        let smallest = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = b1.length; i < len; i++) {\n            let d = info.normal.dot(b1[i].$subtract(c2));\n            if (d < smallest) {\n                smallest = d;\n                info.vertex = b1[i];\n            }\n        }\n        return info;\n    }\n    static intersectPolygon2D(poly1, poly2) {\n        let lp = Polygon.lines(poly1);\n        let g = [];\n        for (let i = 0, len = lp.length; i < len; i++) {\n            let ins = Line.intersectPolygon2D(lp[i], poly2, false);\n            if (ins)\n                g.push(ins);\n        }\n        return Util.flatten(g, true);\n    }\n    static toRects(polys) {\n        let boxes = polys.map((g) => Geom.boundingBox(g));\n        let merged = Util.flatten(boxes, false);\n        boxes.unshift(Geom.boundingBox(merged));\n        return boxes;\n    }\n}\nexport class Curve {\n    static getSteps(steps) {\n        let ts = new Group();\n        for (let i = 0; i <= steps; i++) {\n            let t = i / steps;\n            ts.push(new Pt(t * t * t, t * t, t, 1));\n        }\n        return ts;\n    }\n    static controlPoints(pts, index = 0, copyStart = false) {\n        if (index > pts.length - 1)\n            return new Group();\n        let _index = (i) => (i < pts.length - 1) ? i : pts.length - 1;\n        let p0 = pts[index];\n        index = (copyStart) ? index : index + 1;\n        return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n    static _calcPt(ctrls, params) {\n        let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n        let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n        if (ctrls[0].length > 2) {\n            let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n            return new Pt(x, y, z);\n        }\n        return new Pt(x, y);\n    }\n    static catmullRom(pts, steps = 10) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.catmullRomStep(ts[i], c));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.catmullRomStep(ts[i], cp));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static catmullRomStep(step, ctrls) {\n        let m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static cardinal(pts, steps = 10, tension = 0.5) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.cardinalStep(ts[i], c, tension));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.cardinalStep(ts[i], cp, tension));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static cardinalStep(step, ctrls, tension = 0.5) {\n        let m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n    static bezier(pts, steps = 10) {\n        if (pts.length < 4)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.bezierStep(ts[i], c));\n                }\n                k += 3;\n            }\n        }\n        return ps;\n    }\n    static bezierStep(step, ctrls) {\n        let m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bspline(pts, steps = 10, tension = 1) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                if (tension !== 1) {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n                    }\n                }\n                else {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineStep(ts[i], c));\n                    }\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static bsplineStep(step, ctrls) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bsplineTensionStep(step, ctrls, tension = 1) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n}\n//# sourceMappingURL=Op.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Const } from \"./Util\";\nimport { Curve } from \"./Op\";\nimport { Pt, Group } from \"./Pt\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport class Num {\n    static equals(a, b, threshold = 0.00001) {\n        return Math.abs(a - b) < threshold;\n    }\n    static lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n    }\n    static clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    static boundValue(val, min, max) {\n        let len = Math.abs(max - min);\n        let a = val % len;\n        if (a > max)\n            a -= len;\n        else if (a < min)\n            a += len;\n        return a;\n    }\n    static within(p, a, b) {\n        return p >= Math.min(a, b) && p <= Math.max(a, b);\n    }\n    static randomRange(a, b = 0) {\n        let r = (a > b) ? (a - b) : (b - a);\n        return a + Math.random() * r;\n    }\n    static normalizeValue(n, a, b) {\n        let min = Math.min(a, b);\n        let max = Math.max(a, b);\n        return (n - min) / (max - min);\n    }\n    static sum(pts) {\n        let c = new Pt(pts[0]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            Vec.add(c, pts[i]);\n        }\n        return c;\n    }\n    static average(pts) {\n        return Num.sum(pts).divide(pts.length);\n    }\n    static cycle(t) {\n        return (Math.sin(Math.PI * 2 * t) + 1) / 2;\n    }\n    static mapToRange(n, currA, currB, targetA, targetB) {\n        if (currA == currB)\n            throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n        let min = Math.min(targetA, targetB);\n        let max = Math.max(targetA, targetB);\n        return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n    }\n}\nexport class Geom {\n    static boundAngle(angle) {\n        return Num.boundValue(angle, 0, 360);\n    }\n    static boundRadian(radian) {\n        return Num.boundValue(radian, 0, Const.two_pi);\n    }\n    static toRadian(angle) {\n        return angle * Const.deg_to_rad;\n    }\n    static toDegree(radian) {\n        return radian * Const.rad_to_deg;\n    }\n    static boundingBox(pts) {\n        let minPt = pts.reduce((a, p) => a.$min(p));\n        let maxPt = pts.reduce((a, p) => a.$max(p));\n        return new Group(minPt, maxPt);\n    }\n    static centroid(pts) {\n        return Num.average(pts);\n    }\n    static anchor(pts, ptOrIndex = 0, direction = \"to\") {\n        let method = (direction == \"to\") ? \"subtract\" : \"add\";\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (typeof ptOrIndex == \"number\") {\n                if (ptOrIndex !== i)\n                    pts[i][method](pts[ptOrIndex]);\n            }\n            else {\n                pts[i][method](ptOrIndex);\n            }\n        }\n    }\n    static interpolate(a, b, t = 0.5) {\n        let len = Math.min(a.length, b.length);\n        let d = Pt.make(len);\n        for (let i = 0; i < len; i++) {\n            d[i] = a[i] * (1 - t) + b[i] * t;\n        }\n        return d;\n    }\n    static perpendicular(pt, axis = Const.xy) {\n        let y = axis[1];\n        let x = axis[0];\n        let p = new Pt(pt);\n        let pa = new Pt(p);\n        pa[x] = -p[y];\n        pa[y] = p[x];\n        let pb = new Pt(p);\n        pb[x] = p[y];\n        pb[y] = -p[x];\n        return new Group(pa, pb);\n    }\n    static isPerpendicular(p1, p2) {\n        return new Pt(p1).dot(p2) === 0;\n    }\n    static withinBound(pt, boundPt1, boundPt2) {\n        for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n            if (!Num.within(pt[i], boundPt1[i], boundPt2[i]))\n                return false;\n        }\n        return true;\n    }\n    static sortEdges(pts) {\n        let bounds = Geom.boundingBox(pts);\n        let center = bounds[1].add(bounds[0]).divide(2);\n        let fn = (a, b) => {\n            if (a.length < 2 || b.length < 2)\n                throw new Error(\"Pt dimension cannot be less than 2\");\n            let da = a.$subtract(center);\n            let db = b.$subtract(center);\n            if (da[0] >= 0 && db[0] < 0)\n                return 1;\n            if (da[0] < 0 && db[0] >= 0)\n                return -1;\n            if (da[0] == 0 && db[0] == 0) {\n                if (da[1] >= 0 || db[1] >= 0)\n                    return (da[1] > db[1]) ? 1 : -1;\n                return (db[1] > da[1]) ? 1 : -1;\n            }\n            let det = da.$cross2D(db);\n            if (det < 0)\n                return 1;\n            if (det > 0)\n                return -1;\n            return (da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1]) ? 1 : -1;\n        };\n        return pts.sort(fn);\n    }\n    static scale(ps, scale, anchor) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let scs = (typeof scale == \"number\") ? Pt.make(pts[0].length, scale) : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = pts[i];\n            for (let k = 0, lenP = p.length; k < lenP; k++) {\n                p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n            }\n        }\n        return Geom;\n    }\n    static rotate2D(ps, angle, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let fn = (anchor) ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\n        }\n        return Geom;\n    }\n    static shear2D(ps, scale, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let s = (typeof scale == \"number\") ? [scale, scale] : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let fn = (anchor) ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\n        let tanx = Math.tan(s[0]);\n        let tany = Math.tan(s[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\n        }\n        return Geom;\n    }\n    static reflect2D(ps, line, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let mat = Mat.reflectAt2DMatrix(line[0], line[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, mat));\n        }\n        return Geom;\n    }\n    static cosTable() {\n        let cos = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            cos[i] = Math.cos(i * Math.PI / 180);\n        let find = (rad) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: cos, cos: find };\n    }\n    static sinTable() {\n        let sin = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            sin[i] = Math.sin(i * Math.PI / 180);\n        let find = (rad) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: sin, sin: find };\n    }\n}\nexport class Shaping {\n    static linear(t, c = 1) {\n        return c * t;\n    }\n    static quadraticIn(t, c = 1) {\n        return c * t * t;\n    }\n    static quadraticOut(t, c = 1) {\n        return -c * t * (t - 2);\n    }\n    static quadraticInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n    }\n    static cubicIn(t, c = 1) {\n        return c * t * t * t;\n    }\n    static cubicOut(t, c = 1) {\n        let dt = t - 1;\n        return c * (dt * dt * dt + 1);\n    }\n    static cubicInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n    }\n    static exponentialIn(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, 1 / p);\n    }\n    static exponentialOut(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, p);\n    }\n    static sineIn(t, c = 1) {\n        return -c * Math.cos(t * Const.half_pi) + c;\n    }\n    static sineOut(t, c = 1) {\n        return c * Math.sin(t * Const.half_pi);\n    }\n    static sineInOut(t, c = 1) {\n        return -c / 2 * (Math.cos(Math.PI * t) - 1);\n    }\n    static cosineApprox(t, c = 1) {\n        let t2 = t * t;\n        let t4 = t2 * t2;\n        let t6 = t4 * t2;\n        return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n    }\n    static circularIn(t, c = 1) {\n        return -c * (Math.sqrt(1 - t * t) - 1);\n    }\n    static circularOut(t, c = 1) {\n        let dt = t - 1;\n        return c * Math.sqrt(1 - dt * dt);\n    }\n    static circularInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n    }\n    static elasticIn(t, c = 1, p = 0.7) {\n        let dt = t - 1;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\n    }\n    static elasticOut(t, c = 1, p = 0.7) {\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\n    }\n    static elasticInOut(t, c = 1, p = 0.6) {\n        let dt = t * 2;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        if (t < 0.5) {\n            dt -= 1;\n            return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\n        }\n        else {\n            dt -= 1;\n            return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\n        }\n    }\n    static bounceIn(t, c = 1) {\n        return c - Shaping.bounceOut((1 - t), c);\n    }\n    static bounceOut(t, c = 1) {\n        if (t < (1 / 2.75)) {\n            return c * (7.5625 * t * t);\n        }\n        else if (t < (2 / 2.75)) {\n            t -= 1.5 / 2.75;\n            return c * (7.5625 * t * t + 0.75);\n        }\n        else if (t < (2.5 / 2.75)) {\n            t -= 2.25 / 2.75;\n            return c * (7.5625 * t * t + 0.9375);\n        }\n        else {\n            t -= 2.625 / 2.75;\n            return c * (7.5625 * t * t + 0.984375);\n        }\n    }\n    static bounceInOut(t, c = 1) {\n        return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n    }\n    static sigmoid(t, c = 1, p = 10) {\n        let d = p * (t - 0.5);\n        return c / (1 + Math.exp(-d));\n    }\n    static logSigmoid(t, c = 1, p = 0.7) {\n        p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\n        p = 1 / (1 - p);\n        let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\n        let B = 1 / (1 + Math.exp(p));\n        let C = 1 / (1 + Math.exp(-p));\n        return c * (A - B) / (C - B);\n    }\n    static seat(t, c = 1, p = 0.5) {\n        if ((t < 0.5)) {\n            return c * (Math.pow(2 * t, 1 - p)) / 2;\n        }\n        else {\n            return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\n        }\n    }\n    static quadraticBezier(t, c = 1, p = [0.05, 0.95]) {\n        let a = (typeof p != \"number\") ? p[0] : p;\n        let b = (typeof p != \"number\") ? p[1] : 0.5;\n        let om2a = 1 - 2 * a;\n        if (om2a === 0) {\n            om2a = Const.epsilon;\n        }\n        let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n        return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\n    }\n    static cubicBezier(t, c = 1, p1 = [0.1, 0.7], p2 = [0.9, 0.2]) {\n        let curve = new Group(new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1));\n        return c * Curve.bezierStep(new Pt(t * t * t, t * t, t, 1), Curve.controlPoints(curve)).y;\n    }\n    static quadraticTarget(t, c = 1, p1 = [0.2, 0.35]) {\n        let a = Math.min(1 - Const.epsilon, Math.max(Const.epsilon, p1[0]));\n        let b = Math.min(1, Math.max(0, p1[1]));\n        let A = (1 - b) / (1 - a) - (b / a);\n        let B = (A * (a * a) - b) / a;\n        let y = A * (t * t) - B * t;\n        return c * Math.min(1, Math.max(0, y));\n    }\n    static cliff(t, c = 1, p = 0.5) {\n        return (t > p) ? c : 0;\n    }\n    static step(fn, steps, t, c, ...args) {\n        let s = 1 / steps;\n        let tt = Math.floor(t / s) * s;\n        return fn(tt, c, ...args);\n    }\n}\nexport class Range {\n    constructor(g) {\n        this._dims = 0;\n        this._source = Group.fromPtArray(g);\n        this.calc();\n    }\n    get max() { return this._max.clone(); }\n    get min() { return this._min.clone(); }\n    get magnitude() { return this._mag.clone(); }\n    calc() {\n        if (!this._source)\n            return;\n        let dims = this._source[0].length;\n        this._dims = dims;\n        let max = new Pt(dims);\n        let min = new Pt(dims);\n        let mag = new Pt(dims);\n        for (let i = 0; i < dims; i++) {\n            max[i] = Const.min;\n            min[i] = Const.max;\n            mag[i] = 0;\n            let s = this._source.zipSlice(i);\n            for (let k = 0, len = s.length; k < len; k++) {\n                max[i] = Math.max(max[i], s[k]);\n                min[i] = Math.min(min[i], s[k]);\n                mag[i] = max[i] - min[i];\n            }\n        }\n        this._max = max;\n        this._min = min;\n        this._mag = mag;\n        return this;\n    }\n    mapTo(min, max, exclude) {\n        let target = new Group();\n        for (let i = 0, len = this._source.length; i < len; i++) {\n            let g = this._source[i];\n            let n = new Pt(this._dims);\n            for (let k = 0; k < this._dims; k++) {\n                n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n            }\n            target.push(n);\n        }\n        return target;\n    }\n    append(g, update = true) {\n        if (g[0].length !== this._dims)\n            throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\n        this._source = this._source.concat(g);\n        if (update)\n            this.calc();\n        return this;\n    }\n    ticks(count) {\n        let g = new Group();\n        for (let i = 0; i <= count; i++) {\n            let p = new Pt(this._dims);\n            for (let k = 0, len = this._max.length; k < len; k++) {\n                p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n            }\n            g.push(p);\n        }\n        return g;\n    }\n}\n//# sourceMappingURL=Num.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util, Const } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport class Pt extends Float32Array {\n    constructor(...args) {\n        if (args.length === 1 && typeof args[0] == \"number\") {\n            super(args[0]);\n        }\n        else {\n            super((args.length > 0) ? Util.getArgs(args) : [0, 0]);\n        }\n    }\n    static make(dimensions, defaultValue = 0, randomize = false) {\n        let p = new Float32Array(dimensions);\n        if (defaultValue)\n            p.fill(defaultValue);\n        if (randomize) {\n            for (let i = 0, len = p.length; i < len; i++) {\n                p[i] = p[i] * Math.random();\n            }\n        }\n        return new Pt(p);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get x() { return this[0]; }\n    set x(n) { this[0] = n; }\n    get y() { return this[1]; }\n    set y(n) { this[1] = n; }\n    get z() { return this[2]; }\n    set z(n) { this[2] = n; }\n    get w() { return this[3]; }\n    set w(n) { this[3] = n; }\n    clone() {\n        return new Pt(this);\n    }\n    equals(p, threshold = 0.000001) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            if (Math.abs(this[i] - p[i]) > threshold)\n                return false;\n        }\n        return true;\n    }\n    to(...args) {\n        let p = Util.getArgs(args);\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            this[i] = p[i];\n        }\n        return this;\n    }\n    $to(...args) {\n        return this.clone().to(...args);\n    }\n    toAngle(radian, magnitude, anchorFromPt = false) {\n        let m = (magnitude != undefined) ? magnitude : this.magnitude();\n        let change = [Math.cos(radian) * m, Math.sin(radian) * m];\n        return (anchorFromPt) ? this.add(change) : this.to(change);\n    }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    $take(axis) {\n        let p = [];\n        for (let i = 0, len = axis.length; i < len; i++) {\n            p.push(this[axis[i]] || 0);\n        }\n        return new Pt(p);\n    }\n    $concat(...args) {\n        return new Pt(this.toArray().concat(Util.getArgs(args)));\n    }\n    add(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.add(this, args[0]) : Vec.add(this, Util.getArgs(args));\n        return this;\n    }\n    $add(...args) { return this.clone().add(...args); }\n    subtract(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.subtract(this, args[0]) : Vec.subtract(this, Util.getArgs(args));\n        return this;\n    }\n    $subtract(...args) { return this.clone().subtract(...args); }\n    multiply(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.multiply(this, args[0]) : Vec.multiply(this, Util.getArgs(args));\n        return this;\n    }\n    $multiply(...args) { return this.clone().multiply(...args); }\n    divide(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.divide(this, args[0]) : Vec.divide(this, Util.getArgs(args));\n        return this;\n    }\n    $divide(...args) { return this.clone().divide(...args); }\n    magnitudeSq() { return Vec.dot(this, this); }\n    magnitude() { return Vec.magnitude(this); }\n    unit(magnitude = undefined) {\n        Vec.unit(this, magnitude);\n        return this;\n    }\n    $unit(magnitude = undefined) { return this.clone().unit(magnitude); }\n    dot(...args) { return Vec.dot(this, Util.getArgs(args)); }\n    $cross2D(...args) { return Vec.cross2D(this, Util.getArgs(args)); }\n    $cross(...args) { return Vec.cross(this, Util.getArgs(args)); }\n    $project(...args) {\n        return this.$multiply(this.dot(...args) / this.magnitudeSq());\n    }\n    projectScalar(...args) {\n        return this.dot(...args) / this.magnitude();\n    }\n    abs() {\n        Vec.abs(this);\n        return this;\n    }\n    $abs() {\n        return this.clone().abs();\n    }\n    floor() {\n        Vec.floor(this);\n        return this;\n    }\n    $floor() {\n        return this.clone().floor();\n    }\n    ceil() {\n        Vec.ceil(this);\n        return this;\n    }\n    $ceil() {\n        return this.clone().ceil();\n    }\n    round() {\n        Vec.round(this);\n        return this;\n    }\n    $round() {\n        return this.clone().round();\n    }\n    minValue() {\n        return Vec.min(this);\n    }\n    maxValue() {\n        return Vec.max(this);\n    }\n    $min(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.min(this[i], p[i]);\n        }\n        return m;\n    }\n    $max(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.max(this[i], p[i]);\n        }\n        return m;\n    }\n    angle(axis = Const.xy) {\n        return Math.atan2(this[axis[1]], this[axis[0]]);\n    }\n    angleBetween(p, axis = Const.xy) {\n        return Geom.boundRadian(this.angle(axis)) - Geom.boundRadian(p.angle(axis));\n    }\n    scale(scale, anchor) {\n        Geom.scale(this, scale, anchor || Pt.make(this.length, 0));\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    reflect2D(line, axis) {\n        Geom.reflect2D(this, line, axis);\n        return this;\n    }\n    toString() {\n        return `Pt(${this.join(\", \")})`;\n    }\n    toArray() {\n        return [].slice.call(this);\n    }\n}\nexport class Group extends Array {\n    constructor(...args) {\n        super(...args);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get p1() { return this[0]; }\n    get p2() { return this[1]; }\n    get p3() { return this[2]; }\n    get p4() { return this[3]; }\n    get q1() { return this[this.length - 1]; }\n    get q2() { return this[this.length - 2]; }\n    get q3() { return this[this.length - 3]; }\n    get q4() { return this[this.length - 4]; }\n    clone() {\n        let group = new Group();\n        for (let i = 0, len = this.length; i < len; i++) {\n            group.push(this[i].clone());\n        }\n        return group;\n    }\n    static fromArray(list) {\n        let g = new Group();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = (list[i] instanceof Pt) ? list[i] : new Pt(list[i]);\n            g.push(p);\n        }\n        return g;\n    }\n    static fromPtArray(list) {\n        return Group.from(list);\n    }\n    split(chunkSize, stride, loopBack = false) {\n        let sp = Util.split(this, chunkSize, stride, loopBack);\n        return sp;\n    }\n    insert(pts, index = 0) {\n        Group.prototype.splice.apply(this, [index, 0, ...pts]);\n        return this;\n    }\n    remove(index = 0, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        return Group.prototype.splice.apply(this, param);\n    }\n    segments(pts_per_segment = 2, stride = 1, loopBack = false) {\n        return this.split(pts_per_segment, stride, loopBack);\n    }\n    lines() { return this.segments(2, 1); }\n    centroid() {\n        return Geom.centroid(this);\n    }\n    boundingBox() {\n        return Geom.boundingBox(this);\n    }\n    anchorTo(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"to\"); }\n    anchorFrom(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"from\"); }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    interpolate(t) {\n        t = Num.clamp(t, 0, 1);\n        let chunk = this.length - 1;\n        let tc = 1 / (this.length - 1);\n        let idx = Math.floor(t / tc);\n        return Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n    }\n    moveBy(...args) {\n        return this.add(...args);\n    }\n    moveTo(...args) {\n        let d = new Pt(Util.getArgs(args)).subtract(this[0]);\n        this.moveBy(d);\n        return this;\n    }\n    scale(scale, anchor) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.scale(this[i], scale, anchor || this[0]);\n        }\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n        }\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.shear2D(this[i], scale, anchor || this[0], axis);\n        }\n        return this;\n    }\n    reflect2D(line, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.reflect2D(this[i], line, axis);\n        }\n        return this;\n    }\n    sortByDimension(dim, desc = false) {\n        return this.sort((a, b) => (desc) ? b[dim] - a[dim] : a[dim] - b[dim]);\n    }\n    forEachPt(ptFn, ...args) {\n        if (!this[0][ptFn]) {\n            Util.warn(`${ptFn} is not a function of Pt`);\n            return this;\n        }\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i] = this[i][ptFn](...args);\n        }\n        return this;\n    }\n    add(...args) {\n        return this.forEachPt(\"add\", ...args);\n    }\n    subtract(...args) {\n        return this.forEachPt(\"subtract\", ...args);\n    }\n    multiply(...args) {\n        return this.forEachPt(\"multiply\", ...args);\n    }\n    divide(...args) {\n        return this.forEachPt(\"divide\", ...args);\n    }\n    $matrixAdd(g) {\n        return Mat.add(this, g);\n    }\n    $matrixMultiply(g, transposed = false, elementwise = false) {\n        return Mat.multiply(this, g, transposed, elementwise);\n    }\n    zipSlice(index, defaultValue = false) {\n        return Mat.zipSlice(this, index, defaultValue);\n    }\n    $zip(defaultValue = undefined, useLongest = false) {\n        return Mat.zip(this, defaultValue, useLongest);\n    }\n    toString() {\n        return \"Group[ \" + this.reduce((p, c) => p + c.toString() + \" \", \"\") + \" ]\";\n    }\n}\nexport class Bound extends Group {\n    constructor(...args) {\n        super(...args);\n        this._center = new Pt();\n        this._size = new Pt();\n        this._topLeft = new Pt();\n        this._bottomRight = new Pt();\n        this._inited = false;\n        this.init();\n    }\n    static fromBoundingRect(rect) {\n        let b = new Bound(new Pt(rect.left || 0, rect.top || 0), new Pt(rect.right || 0, rect.bottom || 0));\n        if (rect.width && rect.height)\n            b.size = new Pt(rect.width, rect.height);\n        return b;\n    }\n    static fromGroup(g) {\n        if (g.length < 2)\n            throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n        return new Bound(g[0], g[g.length - 1]);\n    }\n    init() {\n        if (this.p1) {\n            this._size = this.p1.clone();\n            this._inited = true;\n        }\n        if (this.p1 && this.p2) {\n            let a = this.p1;\n            let b = this.p2;\n            this.topLeft = a.$min(b);\n            this._bottomRight = a.$max(b);\n            this._updateSize();\n            this._inited = true;\n        }\n    }\n    clone() {\n        return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n    }\n    _updateSize() {\n        this._size = this._bottomRight.$subtract(this._topLeft).abs();\n        this._updateCenter();\n    }\n    _updateCenter() {\n        this._center = this._size.$multiply(0.5).add(this._topLeft);\n    }\n    _updatePosFromTop() {\n        this._bottomRight = this._topLeft.$add(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromBottom() {\n        this._topLeft = this._bottomRight.$subtract(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromCenter() {\n        let half = this._size.$multiply(0.5);\n        this._topLeft = this._center.$subtract(half);\n        this._bottomRight = this._center.$add(half);\n    }\n    get size() { return new Pt(this._size); }\n    set size(p) {\n        this._size = new Pt(p);\n        this._updatePosFromTop();\n    }\n    get center() { return new Pt(this._center); }\n    set center(p) {\n        this._center = new Pt(p);\n        this._updatePosFromCenter();\n    }\n    get topLeft() { return new Pt(this._topLeft); }\n    set topLeft(p) {\n        this._topLeft = new Pt(p);\n        this[0] = this._topLeft;\n        this._updateSize();\n    }\n    get bottomRight() { return new Pt(this._bottomRight); }\n    set bottomRight(p) {\n        this._bottomRight = new Pt(p);\n        this[1] = this._bottomRight;\n        this._updateSize();\n    }\n    get width() { return (this._size.length > 0) ? this._size.x : 0; }\n    set width(w) {\n        this._size.x = w;\n        this._updatePosFromTop();\n    }\n    get height() { return (this._size.length > 1) ? this._size.y : 0; }\n    set height(h) {\n        this._size.y = h;\n        this._updatePosFromTop();\n    }\n    get depth() { return (this._size.length > 2) ? this._size.z : 0; }\n    set depth(d) {\n        this._size.z = d;\n        this._updatePosFromTop();\n    }\n    get x() { return this.topLeft.x; }\n    get y() { return this.topLeft.y; }\n    get z() { return this.topLeft.z; }\n    get inited() { return this._inited; }\n    update() {\n        this._topLeft = this[0];\n        this._bottomRight = this[1];\n        this._updateSize();\n        return this;\n    }\n}\n//# sourceMappingURL=Pt.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Rectangle, Circle, Polygon } from \"./Op\";\nexport const UIShape = {\n    rectangle: \"rectangle\", circle: \"circle\", polygon: \"polygon\", polyline: \"polyline\", line: \"line\"\n};\nexport const UIPointerActions = {\n    up: \"up\", down: \"down\", move: \"move\", drag: \"drag\", uidrag: \"uidrag\", drop: \"drop\", over: \"over\", out: \"out\", enter: \"enter\", leave: \"leave\", all: \"all\"\n};\nexport class UI {\n    constructor(group, shape, states = {}, id) {\n        this._holds = [];\n        this._group = Group.fromArray(group);\n        this._shape = shape;\n        this._id = id === undefined ? `ui_${(UI._counter++)}` : id;\n        this._states = states;\n        this._actions = {};\n    }\n    static fromRectangle(group, states, id) {\n        return new this(group, UIShape.rectangle, states, id);\n    }\n    static fromCircle(group, states, id) {\n        return new this(group, UIShape.circle, states, id);\n    }\n    static fromPolygon(group, states, id) {\n        return new this(group, UIShape.polygon, states, id);\n    }\n    static fromUI(ui, states, id) {\n        return new this(ui.group, ui.shape, states || ui._states, id);\n    }\n    get id() { return this._id; }\n    set id(d) { this._id = d; }\n    get group() { return this._group; }\n    set group(d) { this._group = d; }\n    get shape() { return this._shape; }\n    set shape(d) { this._shape = d; }\n    state(key, value) {\n        if (!key)\n            return null;\n        if (value !== undefined) {\n            this._states[key] = value;\n            return this;\n        }\n        return this._states[key];\n    }\n    on(key, fn) {\n        if (!this._actions[key])\n            this._actions[key] = [];\n        return UI._addHandler(this._actions[key], fn);\n    }\n    off(key, which) {\n        if (!this._actions[key])\n            return false;\n        if (which === undefined) {\n            delete this._actions[key];\n            return true;\n        }\n        else {\n            return UI._removeHandler(this._actions[key], which);\n        }\n    }\n    listen(key, p) {\n        if (this._actions[key] !== undefined) {\n            if (this._within(p) || this._holds.indexOf(key) >= 0) {\n                UI._trigger(this._actions[key], this, p, key);\n                return true;\n            }\n            else if (this._actions['all']) {\n                UI._trigger(this._actions['all'], this, p, key);\n                return true;\n            }\n        }\n        return false;\n    }\n    hold(key) {\n        this._holds.push(key);\n        return this._holds.length - 1;\n    }\n    unhold(id) {\n        if (id !== undefined) {\n            this._holds = this._holds.splice(id, 1);\n        }\n        else {\n            this._holds = [];\n        }\n    }\n    static track(uis, key, p) {\n        for (let i = 0, len = uis.length; i < len; i++) {\n            uis[i].listen(key, p);\n        }\n    }\n    render(fn) {\n        fn(this._group, this._states);\n    }\n    toString() {\n        return `UI ${this.group.toString}`;\n    }\n    _within(p) {\n        let fn = null;\n        if (this._shape === UIShape.rectangle) {\n            fn = Rectangle.withinBound;\n        }\n        else if (this._shape === UIShape.circle) {\n            fn = Circle.withinBound;\n        }\n        else if (this._shape === UIShape.polygon) {\n            fn = Polygon.hasIntersectPoint;\n        }\n        else {\n            return false;\n        }\n        return fn(this._group, p);\n    }\n    static _trigger(fns, target, pt, type) {\n        if (fns) {\n            for (let i = 0, len = fns.length; i < len; i++) {\n                if (fns[i])\n                    fns[i](target, pt, type);\n            }\n        }\n    }\n    static _addHandler(fns, fn) {\n        if (fn) {\n            fns.push(fn);\n            return fns.length - 1;\n        }\n        else {\n            return -1;\n        }\n    }\n    static _removeHandler(fns, index) {\n        if (index >= 0 && index < fns.length) {\n            let temp = fns.length;\n            fns.splice(index, 1);\n            return (temp > fns.length);\n        }\n        else {\n            return false;\n        }\n    }\n}\nUI._counter = 0;\nexport class UIButton extends UI {\n    constructor(group, shape, states = {}, id) {\n        super(group, shape, states, id);\n        this._hoverID = -1;\n        if (states.hover === undefined)\n            this._states['hover'] = false;\n        if (states.clicks === undefined)\n            this._states['clicks'] = 0;\n        const UA = UIPointerActions;\n        this.on(UA.up, (target, pt, type) => {\n            this.state('clicks', this._states.clicks + 1);\n        });\n        this.on(UA.move, (target, pt, type) => {\n            let hover = this._within(pt);\n            if (hover && !this._states.hover) {\n                this.state('hover', true);\n                UI._trigger(this._actions[UA.enter], this, pt, UA.enter);\n                var _capID = this.hold(UA.move);\n                this._hoverID = this.on(UA.move, (t, p) => {\n                    if (!this._within(p) && !this.state('dragging')) {\n                        this.state('hover', false);\n                        UI._trigger(this._actions[UA.leave], this, pt, UA.leave);\n                        this.off(UA.move, this._hoverID);\n                        this.unhold(_capID);\n                    }\n                });\n            }\n        });\n    }\n    onClick(fn) {\n        return this.on(UIPointerActions.up, fn);\n    }\n    offClick(id) {\n        return this.off(UIPointerActions.up, id);\n    }\n    onHover(enter, leave) {\n        var ids = [undefined, undefined];\n        if (enter)\n            ids[0] = this.on(UIPointerActions.enter, enter);\n        if (leave)\n            ids[1] = this.on(UIPointerActions.leave, leave);\n        return ids;\n    }\n    offHover(enterID, leaveID) {\n        var s = [false, false];\n        if (enterID === undefined || enterID >= 0)\n            s[0] = this.off(UIPointerActions.enter, enterID);\n        if (leaveID === undefined || leaveID >= 0)\n            s[1] = this.off(UIPointerActions.leave, leaveID);\n        return s;\n    }\n}\nexport class UIDragger extends UIButton {\n    constructor(group, shape, states = {}, id) {\n        super(group, shape, states, id);\n        this._draggingID = -1;\n        this._moveHoldID = -1;\n        if (states.dragging === undefined)\n            this._states['dragging'] = false;\n        if (states.offset === undefined)\n            this._states['offset'] = new Pt();\n        const UA = UIPointerActions;\n        this.on(UA.down, (target, pt, type) => {\n            this.state('dragging', true);\n            this.state('offset', new Pt(pt).subtract(target.group[0]));\n            this._moveHoldID = this.hold(UA.move);\n            this._draggingID = this.on(UA.move, (t, p) => {\n                if (this.state('dragging')) {\n                    UI._trigger(this._actions[UA.uidrag], t, p, UA.uidrag);\n                }\n            });\n        });\n        this.on(UA.up, (target, pt, type) => {\n            this.state('dragging', false);\n            this.off(UA.move, this._draggingID);\n            this.unhold(this._moveHoldID);\n            UI._trigger(this._actions[UA.drop], target, pt, type);\n        });\n    }\n    onDrag(fn) {\n        return this.on(UIPointerActions.uidrag, fn);\n    }\n    offDrag(id) {\n        return this.off(UIPointerActions.uidrag, id);\n    }\n    onDrop(fn) {\n        return this.on(UIPointerActions.drop, fn);\n    }\n    offDrop(id) {\n        return this.off(UIPointerActions.drop, id);\n    }\n}\n//# sourceMappingURL=UI.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Bound } from \"./Pt\";\nimport { UIPointerActions as UIA } from \"./UI\";\nexport class Space {\n    constructor() {\n        this.id = \"space\";\n        this.bound = new Bound();\n        this._time = { prev: 0, diff: 0, end: -1 };\n        this.players = {};\n        this.playerCount = 0;\n        this._animID = -1;\n        this._pause = false;\n        this._refresh = undefined;\n        this._pointer = new Pt();\n        this._isReady = false;\n        this._playing = false;\n    }\n    refresh(b) {\n        this._refresh = b;\n        return this;\n    }\n    add(p) {\n        let player = (typeof p == \"function\") ? { animate: p } : p;\n        let k = this.playerCount++;\n        let pid = this.id + k;\n        this.players[pid] = player;\n        player.animateID = pid;\n        if (player.resize && this.bound.inited)\n            player.resize(this.bound);\n        if (this._refresh === undefined)\n            this._refresh = true;\n        return this;\n    }\n    remove(player) {\n        delete this.players[player.animateID];\n        return this;\n    }\n    removeAll() {\n        this.players = {};\n        return this;\n    }\n    play(time = 0) {\n        this._animID = requestAnimationFrame(this.play.bind(this));\n        if (this._pause)\n            return this;\n        this._time.diff = time - this._time.prev;\n        this._time.prev = time;\n        try {\n            this.playItems(time);\n        }\n        catch (err) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n            throw err;\n        }\n        return this;\n    }\n    replay() {\n        this._time.end = -1;\n        this.play();\n    }\n    playItems(time) {\n        this._playing = true;\n        if (this._refresh)\n            this.clear();\n        if (this._isReady) {\n            for (let k in this.players) {\n                if (this.players[k].animate)\n                    this.players[k].animate(time, this._time.diff, this);\n            }\n        }\n        if (this._time.end >= 0 && time > this._time.end) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n        }\n    }\n    pause(toggle = false) {\n        this._pause = (toggle) ? !this._pause : true;\n        return this;\n    }\n    resume() {\n        this._pause = false;\n        return this;\n    }\n    stop(t = 0) {\n        this._time.end = t;\n        return this;\n    }\n    playOnce(duration = 5000) {\n        this.play();\n        this.stop(duration);\n        return this;\n    }\n    render(context) {\n        if (this._renderFunc)\n            this._renderFunc(context, this);\n        return this;\n    }\n    set customRendering(f) { this._renderFunc = f; }\n    get customRendering() { return this._renderFunc; }\n    get isPlaying() { return this._playing; }\n    get outerBound() { return this.bound.clone(); }\n    get innerBound() { return new Bound(Pt.make(this.size.length, 0), this.size.clone()); }\n    get size() { return this.bound.size.clone(); }\n    get center() { return this.size.divide(2); }\n    get width() { return this.bound.width; }\n    get height() { return this.bound.height; }\n}\nexport class MultiTouchSpace extends Space {\n    constructor() {\n        super(...arguments);\n        this._pressed = false;\n        this._dragged = false;\n        this._hasMouse = false;\n        this._hasTouch = false;\n    }\n    get pointer() {\n        let p = this._pointer.clone();\n        p.id = this._pointer.id;\n        return p;\n    }\n    bindCanvas(evt, callback) {\n        this._canvas.addEventListener(evt, callback);\n    }\n    unbindCanvas(evt, callback) {\n        this._canvas.removeEventListener(evt, callback);\n    }\n    bindMouse(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.bindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.bindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.bindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.bindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = true;\n        }\n        else {\n            this.unbindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.unbindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.unbindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = false;\n        }\n        return this;\n    }\n    bindTouch(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.bindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.bindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = true;\n        }\n        else {\n            this.unbindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = false;\n        }\n        return this;\n    }\n    touchesToPoints(evt, which = \"touches\") {\n        if (!evt || !evt[which])\n            return [];\n        let ts = [];\n        for (var i = 0; i < evt[which].length; i++) {\n            let t = evt[which].item(i);\n            ts.push(new Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n        }\n        return ts;\n    }\n    _mouseAction(type, evt) {\n        let px = 0, py = 0;\n        if (evt instanceof MouseEvent) {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    px = evt.pageX - this.outerBound.x;\n                    py = evt.pageY - this.outerBound.y;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        else {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    let c = evt.changedTouches && evt.changedTouches.length > 0;\n                    let touch = evt.changedTouches.item(0);\n                    px = (c) ? touch.pageX - this.outerBound.x : 0;\n                    py = (c) ? touch.pageY - this.outerBound.y : 0;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        if (type) {\n            this._pointer.to(px, py);\n            this._pointer.id = type;\n        }\n    }\n    _mouseDown(evt) {\n        this._mouseAction(UIA.down, evt);\n        this._pressed = true;\n        return false;\n    }\n    _mouseUp(evt) {\n        this._mouseAction(UIA.up, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.drop, evt);\n        this._pressed = false;\n        this._dragged = false;\n        return false;\n    }\n    _mouseMove(evt) {\n        this._mouseAction(UIA.move, evt);\n        if (this._pressed) {\n            this._dragged = true;\n            this._mouseAction(UIA.drag, evt);\n        }\n        return false;\n    }\n    _mouseOver(evt) {\n        this._mouseAction(UIA.over, evt);\n        return false;\n    }\n    _mouseOut(evt) {\n        this._mouseAction(UIA.out, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.drop, evt);\n        this._dragged = false;\n        return false;\n    }\n    _touchMove(evt) {\n        this._mouseMove(evt);\n        evt.preventDefault();\n        return false;\n    }\n}\n//# sourceMappingURL=Space.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Util } from \"./Util\";\nexport class Form {\n    constructor() {\n        this._ready = false;\n    }\n    get ready() { return this._ready; }\n    static _checkSize(pts, required = 2) {\n        if (pts.length < required) {\n            Util.warn(\"Requires 2 or more Pts in this Group.\");\n            return false;\n        }\n        return true;\n    }\n}\nexport class VisualForm extends Form {\n    constructor() {\n        super(...arguments);\n        this._filled = true;\n        this._stroked = true;\n        this._font = new Font(14, \"sans-serif\");\n    }\n    get filled() { return this._filled; }\n    set filled(b) { this._filled = b; }\n    get stroked() { return this._stroked; }\n    set stroked(b) { this._stroked = b; }\n    get currentFont() { return this._font; }\n    _multiple(groups, shape, ...rest) {\n        if (!groups)\n            return this;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            this[shape](groups[i], ...rest);\n        }\n        return this;\n    }\n    fill(c) {\n        return this;\n    }\n    fillOnly(c) {\n        this.stroke(false);\n        return this.fill(c);\n    }\n    stroke(c, width, linejoin, linecap) {\n        return this;\n    }\n    strokeOnly(c, width, linejoin, linecap) {\n        this.fill(false);\n        return this.stroke(c, width, linejoin, linecap);\n    }\n    points(pts, radius, shape) {\n        if (!pts)\n            return;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            this.point(pts[i], radius, shape);\n        }\n        return this;\n    }\n    circles(groups) {\n        return this._multiple(groups, \"circle\");\n    }\n    squares(groups) {\n        return this._multiple(groups, \"square\");\n    }\n    lines(groups) {\n        return this._multiple(groups, \"line\");\n    }\n    polygons(groups) {\n        return this._multiple(groups, \"polygon\");\n    }\n    rects(groups) {\n        return this._multiple(groups, \"rect\");\n    }\n}\nexport class Font {\n    constructor(size = 12, face = \"sans-serif\", weight = \"\", style = \"\", lineHeight = 1.5) {\n        this.size = size;\n        this.face = face;\n        this.style = style;\n        this.weight = weight;\n        this.lineHeight = lineHeight;\n    }\n    get value() { return `${this.style} ${this.weight} ${this.size}px/${this.lineHeight} ${this.face}`; }\n    toString() { return this.value; }\n}\n//# sourceMappingURL=Form.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt } from \"./Pt\";\nexport class Typography {\n    static textWidthEstimator(fn, samples = [\"M\", \"n\", \".\"], distribution = [0.06, 0.8, 0.14]) {\n        let m = samples.map(fn);\n        let avg = new Pt(distribution).dot(m);\n        return (str) => str.length * avg;\n    }\n    static truncate(fn, str, width, tail = \"\") {\n        let trim = Math.floor(str.length * Math.min(1, width / fn(str)));\n        if (trim < str.length) {\n            trim = Math.max(0, trim - tail.length);\n            return [str.substr(0, trim) + tail, trim];\n        }\n        else {\n            return [str, str.length];\n        }\n    }\n    static fontSizeToBox(box, ratio = 1, byHeight = true) {\n        let i = byHeight ? 1 : 0;\n        let h = (box[1][i] - box[0][i]);\n        let f = ratio * h;\n        return function (b) {\n            let nh = (b[1][i] - b[0][i]) / h;\n            return f * nh;\n        };\n    }\n    static fontSizeToThreshold(threshold, direction = 0) {\n        return function (defaultSize, val) {\n            let d = defaultSize * val / threshold;\n            if (direction < 0)\n                return Math.min(d, defaultSize);\n            if (direction > 0)\n                return Math.max(d, defaultSize);\n            return d;\n        };\n    }\n}\n//# sourceMappingURL=Typography.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport class CanvasSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this._pixelScale = 1;\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._offscreen = false;\n        this._initialResize = false;\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pt\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            let id = elem;\n            id = (elem[0] === \"#\" || elem[0] === \".\") ? elem : \"#\" + elem;\n            _selector = document.querySelector(id);\n            _existed = true;\n            this.id = id.substr(1);\n        }\n        if (!_selector) {\n            this._container = this._createElement(\"div\", this.id + \"_container\");\n            this._canvas = this._createElement(\"canvas\", this.id);\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n            this._container = _selector;\n            this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n            this._container.appendChild(this._canvas);\n            this._initialResize = true;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n            this._autoResize = false;\n        }\n        setTimeout(this._ready.bind(this, callback), 100);\n        this._ctx = this._canvas.getContext('2d');\n    }\n    _createElement(elem = \"div\", id) {\n        let d = document.createElement(elem);\n        d.setAttribute(\"id\", id);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this._initialResize = false;\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor)\n            this._bgcolor = opt.bgcolor;\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        if (opt.retina !== false) {\n            let r1 = window.devicePixelRatio || 1;\n            let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n            this._pixelScale = Math.max(1, r1 / r2);\n        }\n        if (opt.offscreen) {\n            this._offscreen = true;\n            this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n            this._offCtx = this._offCanvas.getContext('2d');\n        }\n        else {\n            this._offscreen = false;\n        }\n        return this;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this._canvas.width = this.bound.size.x * this._pixelScale;\n        this._canvas.height = this.bound.size.y * this._pixelScale;\n        this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n        this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        if (this._offscreen) {\n            this._offCanvas.width = this.bound.size.x * this._pixelScale;\n            this._offCanvas.height = this.bound.size.y * this._pixelScale;\n        }\n        if (this._pixelScale != 1) {\n            this._ctx.scale(this._pixelScale, this._pixelScale);\n            this._ctx.translate(0.5, 0.5);\n            if (this._offscreen) {\n                this._offCtx.scale(this._pixelScale, this._pixelScale);\n                this._offCtx.translate(0.5, 0.5);\n            }\n        }\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        this.render(this._ctx);\n        if (evt && !this.isPlaying)\n            this.playOnce(0);\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = (this._autoResize || this._initialResize) ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n        if (b) {\n            let box = Bound.fromBoundingRect(b);\n            box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n            this.resize(box, evt);\n        }\n    }\n    set background(bg) { this._bgcolor = bg; }\n    get background() { return this._bgcolor; }\n    get pixelScale() {\n        return this._pixelScale;\n    }\n    get hasOffscreen() {\n        return this._offscreen;\n    }\n    get offscreenCtx() { return this._offCtx; }\n    get offscreenCanvas() { return this._offCanvas; }\n    getForm() { return new CanvasForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() {\n        return this._isReady;\n    }\n    get ctx() { return this._ctx; }\n    clear(bg) {\n        if (bg)\n            this._bgcolor = bg;\n        let lastColor = this._ctx.fillStyle;\n        if (this._bgcolor && this._bgcolor != \"transparent\") {\n            this._ctx.fillStyle = this._bgcolor;\n            this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        else {\n            this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        this._ctx.fillStyle = lastColor;\n        return this;\n    }\n    clearOffscreen(bg) {\n        if (this._offscreen) {\n            if (bg) {\n                this._offCtx.fillStyle = bg;\n                this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n            }\n            else {\n                this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n            }\n        }\n        return this;\n    }\n    playItems(time) {\n        if (this._isReady) {\n            this._ctx.save();\n            if (this._offscreen)\n                this._offCtx.save();\n            super.playItems(time);\n            this._ctx.restore();\n            if (this._offscreen)\n                this._offCtx.restore();\n            this.render(this._ctx);\n        }\n    }\n}\nexport class CanvasForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._style = {\n            fillStyle: \"#f03\", strokeStyle: \"#fff\",\n            lineWidth: 1, lineJoin: \"bevel\", lineCap: \"butt\",\n        };\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx = this._space.ctx;\n                this._ctx.fillStyle = this._style.fillStyle;\n                this._ctx.strokeStyle = this._style.strokeStyle;\n                this._ctx.lineJoin = \"bevel\";\n                this._ctx.font = this._font.value;\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    useOffscreen(off = true, clear = false) {\n        if (clear)\n            this._space.clearOffscreen((typeof clear == \"string\") ? clear : null);\n        this._ctx = (this._space.hasOffscreen && off) ? this._space.offscreenCtx : this._space.ctx;\n        return this;\n    }\n    renderOffscreen(offset = [0, 0]) {\n        if (this._space.hasOffscreen) {\n            this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n        }\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.filled = c;\n        }\n        else {\n            this.filled = true;\n            this._style.fillStyle = c;\n            this._ctx.fillStyle = c;\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.stroked = c;\n        }\n        else {\n            this.stroked = true;\n            this._style.strokeStyle = c;\n            this._ctx.strokeStyle = c;\n            if (width) {\n                this._ctx.lineWidth = width;\n                this._style.lineWidth = width;\n            }\n            if (linejoin) {\n                this._ctx.lineJoin = linejoin;\n                this._style.lineJoin = linejoin;\n            }\n            if (linecap) {\n                this._ctx.lineCap = linecap;\n                this._style.lineCap = linecap;\n            }\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        if (this._estimateTextWidth)\n            this.fontWidthEstimate(true);\n        return this;\n    }\n    fontWidthEstimate(estimate = true) {\n        this._estimateTextWidth = (estimate) ? Typo.textWidthEstimator(((c) => this._ctx.measureText(c).width)) : undefined;\n        return this;\n    }\n    getTextWidth(c) {\n        return (!this._estimateTextWidth) ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n    }\n    _textTruncate(str, width, tail = \"\") {\n        return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n    _textAlign(box, vertical, offset, center) {\n        if (!center)\n            center = Rectangle.center(box);\n        var px = box[0][0];\n        if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n            px = box[1][0];\n        }\n        else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n            px = center[0];\n        }\n        var py = center[1];\n        if (vertical == \"top\" || vertical == \"start\") {\n            py = box[0][1];\n        }\n        else if (vertical == \"end\" || vertical == \"bottom\") {\n            py = box[1][1];\n        }\n        return (offset) ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n    }\n    reset() {\n        for (let k in this._style) {\n            if (this._style.hasOwnProperty(k)) {\n                this._ctx[k] = this._style[k];\n            }\n        }\n        this._font = new Font();\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    _paint() {\n        if (this._filled)\n            this._ctx.fill();\n        if (this._stroked)\n            this._ctx.stroke();\n    }\n    point(p, radius = 5, shape = \"square\") {\n        if (!p)\n            return;\n        if (!CanvasForm[shape])\n            throw new Error(`${shape} is not a static function of CanvasForm`);\n        CanvasForm[shape](this._ctx, p, radius);\n        this._paint();\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n        ctx.closePath();\n    }\n    circle(pts) {\n        CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n        this._paint();\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        if (!pt)\n            return;\n        let x1 = pt[0] - halfsize;\n        let y1 = pt[1] - halfsize;\n        let x2 = pt[0] + halfsize;\n        let y2 = pt[1] + halfsize;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y2);\n        ctx.lineTo(x2, y2);\n        ctx.lineTo(x2, y1);\n        ctx.closePath();\n    }\n    square(pt, halfsize) {\n        CanvasForm.square(this._ctx, pt, halfsize);\n        this._paint();\n        return this;\n    }\n    static line(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n    }\n    line(pts) {\n        CanvasForm.line(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static polygon(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n        ctx.closePath();\n    }\n    polygon(pts) {\n        CanvasForm.polygon(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        ctx.lineTo(pts[0][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[0][1]);\n        ctx.closePath();\n    }\n    rect(pts) {\n        CanvasForm.rect(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static image(ctx, img, target = new Pt(), orig) {\n        if (typeof target[0] === \"number\") {\n            ctx.drawImage(img, target[0], target[1]);\n        }\n        else {\n            let t = target;\n            if (orig) {\n                ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n            else {\n                ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n        }\n    }\n    image(img, target, original) {\n        CanvasForm.image(this._ctx, img, target, original);\n        return this;\n    }\n    static text(ctx, pt, txt, maxWidth) {\n        if (!pt)\n            return;\n        ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n    text(pt, txt, maxWidth) {\n        CanvasForm.text(this._ctx, pt, txt, maxWidth);\n        return this;\n    }\n    textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n        if (overrideBaseline)\n            this._ctx.textBaseline = verticalAlign;\n        let size = Rectangle.size(box);\n        let t = this._textTruncate(txt, size[0], tail);\n        this.text(this._textAlign(box, verticalAlign), t[0]);\n        return this;\n    }\n    paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n        let size = Rectangle.size(box);\n        this._ctx.textBaseline = \"top\";\n        let lstep = this._font.size * lineHeight;\n        let nextLine = (sub, buffer = [], cc = 0) => {\n            if (!sub)\n                return buffer;\n            if (crop && cc * lstep > size[1] - lstep * 2)\n                return buffer;\n            if (cc > 10000)\n                throw new Error(\"max recursion reached (10000)\");\n            let t = this._textTruncate(sub, size[0], \"\");\n            let newln = t[0].indexOf(\"\\n\");\n            if (newln >= 0) {\n                buffer.push(t[0].substr(0, newln));\n                return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n            }\n            let dt = t[0].lastIndexOf(\" \") + 1;\n            if (dt <= 0 || t[1] === sub.length)\n                dt = undefined;\n            let line = t[0].substr(0, dt);\n            buffer.push(line);\n            return (t[1] <= 0 || t[1] === sub.length) ? buffer : nextLine(sub.substr((dt || t[1])), buffer, cc + 1);\n        };\n        let lines = nextLine(txt);\n        let lsize = lines.length * lstep;\n        let lbox = box;\n        if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n            let lpad = (size[1] - lsize) / 2;\n            if (crop)\n                lpad = Math.max(0, lpad);\n            lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n        }\n        else if (verticalAlign == \"bottom\") {\n            lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n        }\n        else {\n            lbox = new Group(box[0], box[0].$add(size[0], lsize));\n        }\n        let center = Rectangle.center(lbox);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n        }\n        return this;\n    }\n    alignText(alignment = \"left\", baseline = \"alphabetic\") {\n        if (baseline == \"center\")\n            baseline = \"middle\";\n        if (baseline == \"baseline\")\n            baseline = \"alphabetic\";\n        this._ctx.textAlign = alignment;\n        this._ctx.textBaseline = baseline;\n        return this;\n    }\n    log(txt) {\n        let w = this._ctx.measureText(txt).width + 20;\n        this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n        this.fill(\"#fff\").text([10, 14], txt);\n        return this;\n    }\n}\n//# sourceMappingURL=Canvas.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Line, Triangle } from \"./Op\";\nimport { Const } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nimport { Vec } from \"./LinearAlgebra\";\nexport class Create {\n    static distributeRandom(bound, count, dimensions = 2) {\n        let pts = new Group();\n        for (let i = 0; i < count; i++) {\n            let p = [bound.x + Math.random() * bound.width];\n            if (dimensions > 1)\n                p.push(bound.y + Math.random() * bound.height);\n            if (dimensions > 2)\n                p.push(bound.z + Math.random() * bound.depth);\n            pts.push(new Pt(p));\n        }\n        return pts;\n    }\n    static distributeLinear(line, count) {\n        let ln = Line.subpoints(line, count - 2);\n        ln.unshift(line[0]);\n        ln.push(line[line.length - 1]);\n        return ln;\n    }\n    static gridPts(bound, columns, rows, orientation = [0.5, 0.5]) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).$divide(columns, rows);\n        let offset = unit.$multiply(orientation);\n        let g = new Group();\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(bound.topLeft.$add(unit.$multiply(c, r)).add(offset));\n            }\n        }\n        return g;\n    }\n    static gridCells(bound, columns, rows) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).divide(columns, rows);\n        let g = [];\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(new Group(bound.topLeft.$add(unit.$multiply(c, r)), bound.topLeft.$add(unit.$multiply(c, r).add(unit))));\n            }\n        }\n        return g;\n    }\n    static radialPts(center, radius, count) {\n        let g = new Group();\n        let a = Const.two_pi / count;\n        for (let i = 0; i < count; i++) {\n            g.push(new Pt(center).toAngle(a * i - Const.half_pi, radius, true));\n        }\n        return g;\n    }\n    static noisePts(pts, dx = 0.01, dy = 0.01, rows = 0, columns = 0) {\n        let seed = Math.random();\n        let g = new Group();\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let np = new Noise(pts[i]);\n            let r = (rows && rows > 0) ? Math.floor(i / rows) : i;\n            let c = (columns && columns > 0) ? i % columns : i;\n            np.initNoise(dx * c, dy * r);\n            np.seed(seed);\n            g.push(np);\n        }\n        return g;\n    }\n    static delaunay(pts) {\n        return Delaunay.from(pts);\n    }\n}\nconst grad3 = [\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\n    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]\n];\nconst permTable = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 9, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n];\nexport class Noise extends Pt {\n    constructor(...args) {\n        super(...args);\n        this.perm = [];\n        this._n = new Pt(0.01, 0.01);\n        this.perm = permTable.concat(permTable);\n    }\n    initNoise(...args) {\n        this._n = new Pt(...args);\n    }\n    step(x = 0, y = 0) {\n        this._n.add(x, y);\n    }\n    seed(s) {\n        if (s > 0 && s < 1)\n            s *= 65536;\n        s = Math.floor(s);\n        if (s < 256)\n            s |= s << 8;\n        for (let i = 0; i < 255; i++) {\n            let v = (i & 1) ? permTable[i] ^ (s & 255) : permTable[i] ^ ((s >> 8) & 255);\n            this.perm[i] = this.perm[i + 256] = v;\n        }\n    }\n    noise2D() {\n        let i = Math.max(0, Math.floor(this._n[0])) % 255;\n        let j = Math.max(0, Math.floor(this._n[1])) % 255;\n        let x = (this._n[0] % 255) - i;\n        let y = (this._n[1] % 255) - j;\n        let n00 = Vec.dot(grad3[(i + this.perm[j]) % 12], [x, y, 0]);\n        let n01 = Vec.dot(grad3[(i + this.perm[j + 1]) % 12], [x, y - 1, 0]);\n        let n10 = Vec.dot(grad3[(i + 1 + this.perm[j]) % 12], [x - 1, y, 0]);\n        let n11 = Vec.dot(grad3[(i + 1 + this.perm[j + 1]) % 12], [x - 1, y - 1, 0]);\n        let _fade = (f) => f * f * f * (f * (f * 6 - 15) + 10);\n        let tx = _fade(x);\n        return Num.lerp(Num.lerp(n00, n10, tx), Num.lerp(n01, n11, tx), _fade(y));\n    }\n}\nexport class Delaunay extends Group {\n    constructor() {\n        super(...arguments);\n        this._mesh = [];\n    }\n    delaunay(triangleOnly = true) {\n        if (this.length < 3)\n            return [];\n        this._mesh = [];\n        let n = this.length;\n        let indices = [];\n        for (let i = 0; i < n; i++)\n            indices[i] = i;\n        indices.sort((i, j) => this[j][0] - this[i][0]);\n        let pts = this.slice();\n        let st = this._superTriangle();\n        pts = pts.concat(st);\n        let opened = [this._circum(n, n + 1, n + 2, st)];\n        let closed = [];\n        let tris = [];\n        for (let i = 0, len = indices.length; i < len; i++) {\n            let c = indices[i];\n            let edges = [];\n            let j = opened.length;\n            if (!this._mesh[c])\n                this._mesh[c] = {};\n            while (j--) {\n                let circum = opened[j];\n                let radius = circum.circle[1][0];\n                let d = pts[c].$subtract(circum.circle[0]);\n                if (d[0] > 0 && d[0] * d[0] > radius * radius) {\n                    closed.push(circum);\n                    tris.push(circum.triangle);\n                    opened.splice(j, 1);\n                    continue;\n                }\n                if (d[0] * d[0] + d[1] * d[1] - radius * radius > Const.epsilon) {\n                    continue;\n                }\n                edges.push(circum.i, circum.j, circum.j, circum.k, circum.k, circum.i);\n                opened.splice(j, 1);\n            }\n            Delaunay._dedupe(edges);\n            j = edges.length;\n            while (j > 1) {\n                opened.push(this._circum(edges[--j], edges[--j], c, false, pts));\n            }\n        }\n        for (let i = 0, len = opened.length; i < len; i++) {\n            let o = opened[i];\n            if (o.i < n && o.j < n && o.k < n) {\n                closed.push(o);\n                tris.push(o.triangle);\n                this._cache(o);\n            }\n        }\n        return (triangleOnly) ? tris : closed;\n    }\n    voronoi() {\n        let vs = [];\n        let n = this._mesh;\n        for (let i = 0, len = n.length; i < len; i++) {\n            vs.push(this.neighborPts(i, true));\n        }\n        return vs;\n    }\n    mesh() {\n        return this._mesh;\n    }\n    neighborPts(i, sort = false) {\n        let cs = new Group();\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k].circle[0]);\n        }\n        return (sort) ? Geom.sortEdges(cs) : cs;\n    }\n    neighbors(i) {\n        let cs = [];\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k]);\n        }\n        return cs;\n    }\n    _cache(o) {\n        this._mesh[o.i][`${Math.min(o.j, o.k)}-${Math.max(o.j, o.k)}`] = o;\n        this._mesh[o.j][`${Math.min(o.i, o.k)}-${Math.max(o.i, o.k)}`] = o;\n        this._mesh[o.k][`${Math.min(o.i, o.j)}-${Math.max(o.i, o.j)}`] = o;\n    }\n    _superTriangle() {\n        let minPt = this[0];\n        let maxPt = this[0];\n        for (let i = 1, len = this.length; i < len; i++) {\n            minPt = minPt.$min(this[i]);\n            maxPt = maxPt.$max(this[i]);\n        }\n        let d = maxPt.$subtract(minPt);\n        let mid = minPt.$add(maxPt).divide(2);\n        let dmax = Math.max(d[0], d[1]);\n        return new Group(mid.$subtract(20 * dmax, dmax), mid.$add(0, 20 * dmax), mid.$add(20 * dmax, -dmax));\n    }\n    _triangle(i, j, k, pts = this) {\n        return new Group(pts[i], pts[j], pts[k]);\n    }\n    _circum(i, j, k, tri, pts = this) {\n        let t = tri || this._triangle(i, j, k, pts);\n        return {\n            i: i,\n            j: j,\n            k: k,\n            triangle: t,\n            circle: Triangle.circumcircle(t)\n        };\n    }\n    static _dedupe(edges) {\n        let j = edges.length;\n        while (j > 1) {\n            let b = edges[--j];\n            let a = edges[--j];\n            let i = j;\n            while (i > 1) {\n                let n = edges[--i];\n                let m = edges[--i];\n                if ((a == m && b == n) || (a == n && b == m)) {\n                    edges.splice(j, 2);\n                    edges.splice(i, 2);\n                    break;\n                }\n            }\n        }\n        return edges;\n    }\n}\n//# sourceMappingURL=Create.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport class Color extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mode = \"rgb\";\n        this._isNorm = false;\n    }\n    static from(...args) {\n        let p = [1, 1, 1, 1];\n        let c = Util.getArgs(args);\n        for (let i = 0, len = p.length; i < len; i++) {\n            if (i < c.length)\n                p[i] = c[i];\n        }\n        return new Color(p);\n    }\n    static fromHex(hex) {\n        if (hex[0] == \"#\")\n            hex = hex.substr(1);\n        if (hex.length <= 3) {\n            let fn = (i) => hex[i] || \"F\";\n            hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n        }\n        let alpha = 1;\n        if (hex.length === 8) {\n            alpha = hex.substr(6) && 0xFF / 255;\n            hex = hex.substring(0, 6);\n        }\n        let hexVal = parseInt(hex, 16);\n        return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n    static rgb(...args) { return Color.from(...args).toMode(\"rgb\"); }\n    static hsl(...args) { return Color.from(...args).toMode(\"hsl\"); }\n    static hsb(...args) { return Color.from(...args).toMode(\"hsb\"); }\n    static lab(...args) { return Color.from(...args).toMode(\"lab\"); }\n    static lch(...args) { return Color.from(...args).toMode(\"lch\"); }\n    static luv(...args) { return Color.from(...args).toMode(\"luv\"); }\n    static xyz(...args) { return Color.from(...args).toMode(\"xyz\"); }\n    static maxValues(mode) { return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]); }\n    get hex() { return this.toString(\"hex\"); }\n    get rgb() { return this.toString(\"rgb\"); }\n    get rgba() { return this.toString(\"rgba\"); }\n    clone() {\n        let c = new Color(this);\n        c.toMode(this._mode);\n        return c;\n    }\n    toMode(mode, convert = false) {\n        if (convert) {\n            let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n            if (Color[fname]) {\n                this.to(Color[fname](this, this._isNorm, this._isNorm));\n            }\n            else {\n                throw new Error(\"Cannot convert color with \" + fname);\n            }\n        }\n        this._mode = mode;\n        return this;\n    }\n    get mode() { return this._mode; }\n    get r() { return this[0]; }\n    set r(n) { this[0] = n; }\n    get g() { return this[1]; }\n    set g(n) { this[1] = n; }\n    get b() { return this[2]; }\n    set b(n) { this[2] = n; }\n    get h() { return (this._mode == \"lch\") ? this[2] : this[0]; }\n    set h(n) {\n        let i = (this._mode == \"lch\") ? 2 : 0;\n        this[i] = n;\n    }\n    get s() { return this[1]; }\n    set s(n) { this[1] = n; }\n    get l() { return (this._mode == \"hsl\") ? this[2] : this[0]; }\n    set l(n) {\n        let i = (this._mode == \"hsl\") ? 2 : 0;\n        this[i] = n;\n    }\n    get a() { return this[1]; }\n    set a(n) { this[1] = n; }\n    get c() { return this[1]; }\n    set c(n) { this[1] = n; }\n    get u() { return this[1]; }\n    set u(n) { this[1] = n; }\n    get v() { return this[2]; }\n    set v(n) { this[2] = n; }\n    get alpha() { return (this.length > 3) ? this[3] : 1; }\n    get normalized() { return this._isNorm; }\n    set normalized(b) { this._isNorm = b; }\n    normalize(toNorm = true) {\n        if (this._isNorm == toNorm)\n            return this;\n        let ranges = Color.ranges[this._mode];\n        for (let i = 0; i < 3; i++) {\n            this[i] = (!toNorm)\n                ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1])\n                : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n        }\n        this._isNorm = toNorm;\n        return this;\n    }\n    $normalize(toNorm = true) { return this.clone().normalize(toNorm); }\n    toString(format = \"mode\") {\n        if (format == \"hex\") {\n            let _hex = (n) => {\n                let s = Math.floor(n).toString(16);\n                return (s.length < 2) ? '0' + s : s;\n            };\n            return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n        }\n        else if (format == \"rgba\") {\n            return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n        }\n        else if (format == \"rgb\") {\n            return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n        }\n        else {\n            return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n        }\n    }\n    static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        let l = h;\n        if (max == min) {\n            h = 0;\n            s = 0;\n        }\n        else {\n            let d = max - min;\n            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);\n            h = 0;\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsl(((normalizedOutput) ? h / 60 : h * 60), s, l, rgb.alpha);\n    }\n    static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, l] = hsl;\n        if (!normalizedInput)\n            h = h / 360;\n        if (s == 0)\n            return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n        let q = (l <= 0.5) ? l * (1 + s) : l + s - (l * s);\n        let p = 2 * l - q;\n        let convert = (t) => {\n            t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;\n            if (t * 6 < 1) {\n                return p + (q - p) * t * 6;\n            }\n            else if (t * 2 < 1) {\n                return q;\n            }\n            else if (t * 3 < 2) {\n                return p + (q - p) * ((2 / 3) - t) * 6;\n            }\n            else {\n                return p;\n            }\n        };\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * convert((h + 1 / 3)), sc * convert(h), sc * convert((h - 1 / 3)), hsl.alpha);\n    }\n    static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let d = max - min;\n        let h = 0;\n        let s = (max === 0) ? 0 : d / max;\n        let v = max;\n        if (max != min) {\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsb(((normalizedOutput) ? h / 60 : h * 60), s, v, rgb.alpha);\n    }\n    static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, v] = hsb;\n        if (!normalizedInput)\n            h = h / 360;\n        let i = Math.floor(h * 6);\n        let f = h * 6 - i;\n        let p = v * (1 - s);\n        let q = v * (1 - f * s);\n        let t = v * (1 - (1 - f) * s);\n        let pick = [\n            [v, t, p], [q, v, p], [p, v, t],\n            [p, q, v], [t, p, v], [v, p, q]\n        ];\n        let c = pick[i % 6];\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n    static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n    static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n    static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? luv.$normalize(false) : luv;\n        return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (!normalizedInput) ? rgb.$normalize() : rgb.clone();\n        for (let i = 0; i < 3; i++) {\n            c[i] = (c[i] > 0.04045) ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n            if (!normalizedOutput)\n                c[i] = c[i] * 100;\n        }\n        let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (!normalizedInput) ? xyz.$normalize() : xyz;\n        let rgb = [\n            x * 3.2404542 + y * -1.5371385 + z * -0.4985314,\n            x * -0.9692660 + y * 1.8760108 + z * 0.0415560,\n            x * 0.0556434 + y * -0.2040259 + z * 1.0572252\n        ];\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = (rgb[i] < 0) ? 0 : (rgb[i] > 0.0031308) ? (1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055) : (12.92 * rgb[i]);\n            rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n            if (!normalizedOutput)\n                rgb[i] = Math.round(rgb[i] * 255);\n        }\n        let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? xyz.$normalize(false) : xyz.clone();\n        c.divide(Color.D65);\n        let fn = (n) => (n > 0.008856) ? Math.pow(n, 1 / 3) : (7.787 * n) + 16 / 116;\n        let cy = fn(c[1]);\n        let cc = Color.lab((116 * cy) - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let y = (c[0] + 16) / 116;\n        let x = (c[1] / 500) + y;\n        let z = y - c[2] / 200;\n        let fn = (n) => {\n            let nnn = n * n * n;\n            return (nnn > 0.008856) ? nnn : (n - 16 / 116) / 7.787;\n        };\n        let d = Color.D65;\n        let cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (normalizedInput) ? xyz.$normalize(false) : xyz;\n        let u = (4 * x) / (x + (15 * y) + (3 * z));\n        let v = (9 * y) / (x + (15 * y) + (3 * z));\n        y = y / 100;\n        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y + 16 / 116);\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let L = (116 * y) - 16;\n        return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n    static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n        let [l, u, v] = (normalizedInput) ? luv.$normalize(false) : luv;\n        let y = (l + 16) / 116;\n        let cubeY = y * y * y;\n        y = (cubeY > 0.008856) ? cubeY : (y - 16 / 116) / 7.787;\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        u = u / (13 * l) + refU;\n        v = v / (13 * l) + refV;\n        y = y * 100;\n        let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n        let z = (9 * y - (15 * v * y) - (v * x)) / (3 * v);\n        return Color.xyz(x, y, z, luv.alpha);\n    }\n    static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n        return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n    static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        let rad = Geom.toRadian(c[2]);\n        return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n}\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n    rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n    hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n    lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n    luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n    xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};\n//# sourceMappingURL=Color.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Util } from './Util';\nimport { Pt, Bound } from './Pt';\nexport class DOMSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this.id = \"domspace\";\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._css = {};\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pts\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            _selector = document.querySelector(elem);\n            _existed = true;\n            this.id = elem.substr(1);\n        }\n        if (!_selector) {\n            this._container = DOMSpace.createElement(\"div\", \"pts_container\");\n            this._canvas = DOMSpace.createElement(\"div\", \"pts_element\");\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n        }\n        setTimeout(this._ready.bind(this, callback), 50);\n    }\n    static createElement(elem = \"div\", id, appendTo) {\n        let d = document.createElement(elem);\n        if (id)\n            d.setAttribute(\"id\", id);\n        if (appendTo && appendTo.appendChild)\n            appendTo.appendChild(d);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this.refresh(false);\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor) {\n            this._bgcolor = opt.bgcolor;\n        }\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        return this;\n    }\n    getForm() {\n        return null;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            delete this._css['width'];\n            delete this._css['height'];\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = Bound.fromBoundingRect(this._container.getBoundingClientRect());\n        if (this._autoResize) {\n            this.styles({ width: \"100%\", height: \"100%\" }, true);\n        }\n        else {\n            this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        }\n        this.resize(b, evt);\n    }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() { return this._isReady; }\n    clear(bg) {\n        if (bg)\n            this.background = bg;\n        this._canvas.innerHTML = \"\";\n        return this;\n    }\n    set background(bg) {\n        this._bgcolor = bg;\n        this._container.style.backgroundColor = this._bgcolor;\n    }\n    get background() { return this._bgcolor; }\n    style(key, val, update = false) {\n        this._css[key] = val;\n        if (update)\n            this._canvas.style[key] = val;\n        return this;\n    }\n    styles(styles, update = false) {\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k))\n                this.style(k, styles[k], update);\n        }\n        return this;\n    }\n    static setAttr(elem, data) {\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                elem.setAttribute(k, data[k]);\n            }\n        }\n        return elem;\n    }\n    static getInlineStyles(data) {\n        let str = \"\";\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (data[k])\n                    str += `${k}: ${data[k]}; `;\n            }\n        }\n        return str;\n    }\n}\nexport class HTMLSpace extends DOMSpace {\n    getForm() {\n        return new HTMLForm(this);\n    }\n    static htmlElement(parent, name, id, autoClass = true) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElement(name);\n            elem.setAttribute(\"id\", id);\n            if (autoClass)\n                elem.setAttribute(\"class\", id.substring(0, id.indexOf(\"-\")));\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + HTMLForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class HTMLForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"background\": \"#f03\",\n                \"border-color\": \"#fff\",\n                \"color\": \"#000\",\n                \"border-width\": \"1px\",\n                \"border-radius\": \"0\",\n                \"border-style\": \"solid\",\n                \"position\": \"absolute\",\n                \"top\": 0,\n                \"left\": 0,\n                \"width\": 0,\n                \"height\": 0\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_dom_\" + (HTMLForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v, unit = '') {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = `${v}${unit}`;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n            if (!c)\n                this.styleTo(\"background\", \"transparent\");\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"background\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n            if (!c)\n                this.styleTo(\"border-width\", 0);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"border-color\", c);\n            this.styleTo(\"border-width\", (width || 1) + \"px\");\n        }\n        return this;\n    }\n    fillText(c) {\n        this.styleTo(\"color\", c);\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"background\": \"#f03\", \"border-color\": \"#fff\",\n            \"border-width\": \"1px\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(HTMLForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${HTMLForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"background: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"border: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('background') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('border-width') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return HTMLSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static rectStyle(ctx, pt, size) {\n        ctx.style[\"left\"] = pt[0] + \"px\";\n        ctx.style[\"top\"] = pt[1] + \"px\";\n        ctx.style[\"width\"] = size[0] + \"px\";\n        ctx.style[\"height\"] = size[1] + \"px\";\n        return ctx;\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return HTMLForm.circle(ctx, pt, radius);\n        }\n        else {\n            return HTMLForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        if (shape == \"circle\")\n            this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-circle ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(radius), new Pt(radius * 2, radius * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-square ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(halfsize), new Pt(halfsize * 2, halfsize * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        HTMLForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-rect ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, pts[0], pts[1]);\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"0\");\n        HTMLForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, {\n            position: 'absolute',\n            class: `pts-form pts-text ${ctx.currentClass}`,\n            left: pt[0],\n            top: pt[1],\n        });\n        elem.textContent = txt;\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        HTMLForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        Util.warn(\"arc is not implemented in HTMLForm\");\n        return this;\n    }\n    line(pts) {\n        Util.warn(\"line is not implemented in HTMLForm\");\n        return this;\n    }\n    polygon(pts) {\n        Util.warn(\"polygon is not implemented in HTMLForm\");\n        return this;\n    }\n}\nHTMLForm.groupID = 0;\nHTMLForm.domID = 0;\n//# sourceMappingURL=Dom.js.map","/*! Source code licensed under Apache License 2.0. Copyright  2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\nimport { VisualForm, Font } from \"./Form\";\nimport { Geom } from './Num';\nimport { Const } from './Util';\nimport { Pt, Group } from './Pt';\nimport { Rectangle } from \"./Op\";\nimport { DOMSpace } from \"./Dom\";\nexport class SVGSpace extends DOMSpace {\n    constructor(elem, callback) {\n        super(elem, callback);\n        this.id = \"svgspace\";\n        this._bgcolor = \"#999\";\n        if (this._canvas.nodeName.toLowerCase() != \"svg\") {\n            let s = SVGSpace.svgElement(this._canvas, \"svg\", `${this.id}_svg`);\n            this._container = this._canvas;\n            this._canvas = s;\n        }\n    }\n    getForm() { return new SVGForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    resize(b, evt) {\n        super.resize(b, evt);\n        SVGSpace.setAttr(this.element, {\n            \"viewBox\": `0 0 ${this.bound.width} ${this.bound.height}`,\n            \"width\": `${this.bound.width}`,\n            \"height\": `${this.bound.height}`,\n            \"xmlns\": \"http://www.w3.org/2000/svg\",\n            \"version\": \"1.1\"\n        });\n        return this;\n    }\n    static svgElement(parent, name, id) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n            elem.setAttribute(\"id\", id);\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + SVGForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class SVGForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"fill\": \"#f03\",\n                \"stroke\": \"#fff\",\n                \"stroke-width\": 1,\n                \"stroke-linejoin\": \"bevel\",\n                \"stroke-linecap\": \"sqaure\"\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_svg_\" + (SVGForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v) {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = v;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"fill\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"stroke\", c);\n            if (width)\n                this.styleTo(\"stroke-width\", width);\n            if (linejoin)\n                this.styleTo(\"stroke-linejoin\", linejoin);\n            if (linecap)\n                this.styleTo(\"stroke-linecap\", linecap);\n        }\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"fill\": \"#f03\", \"stroke\": \"#fff\",\n            \"stroke-width\": 1,\n            \"stroke-linejoin\": \"bevel\",\n            \"stroke-linecap\": \"sqaure\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(SVGForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${SVGForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"fill: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"stroke: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('fill') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('stroke') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return DOMSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return SVGForm.circle(ctx, pt, radius);\n        }\n        else {\n            return SVGForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        SVGForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = SVGSpace.svgElement(ctx.group, \"circle\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            cx: pt[0],\n            cy: pt[1],\n            r: radius,\n            'class': `pts-svgform pts-circle ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        SVGForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        let elem = SVGSpace.svgElement(ctx.group, \"path\", SVGForm.getID(ctx));\n        const start = new Pt(pt).toAngle(startAngle, radius, true);\n        const end = new Pt(pt).toAngle(endAngle, radius, true);\n        const diff = Geom.boundAngle(endAngle) - Geom.boundAngle(startAngle);\n        let largeArc = (diff > Const.pi) ? true : false;\n        if (cc)\n            largeArc = !largeArc;\n        const sweep = (cc) ? \"0\" : \"1\";\n        const d = `M ${start[0]} ${start[1]} A ${radius} ${radius} 0 ${largeArc ? \"1\" : \"0\"} ${sweep} ${end[0]} ${end[1]}`;\n        DOMSpace.setAttr(elem, {\n            d: d,\n            'class': `pts-svgform pts-arc ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        this.nextID();\n        SVGForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x: pt[0] - halfsize,\n            y: pt[1] - halfsize,\n            width: halfsize * 2,\n            height: halfsize * 2,\n            'class': `pts-svgform pts-square ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        SVGForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static line(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        if (pts.length > 2)\n            return SVGForm._poly(ctx, pts, false);\n        let elem = SVGSpace.svgElement(ctx.group, \"line\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x1: pts[0][0],\n            y1: pts[0][1],\n            x2: pts[1][0],\n            y2: pts[1][1],\n            'class': `pts-svgform pts-line ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    line(pts) {\n        this.nextID();\n        SVGForm.line(this._ctx, pts);\n        return this;\n    }\n    static _poly(ctx, pts, closePath = true) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, ((closePath) ? \"polygon\" : \"polyline\"), SVGForm.getID(ctx));\n        let points = pts.reduce((a, p) => a + `${p[0]},${p[1]} `, \"\");\n        DOMSpace.setAttr(elem, {\n            points: points,\n            'class': `pts-svgform pts-polygon ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    static polygon(ctx, pts) {\n        return SVGForm._poly(ctx, pts, true);\n    }\n    polygon(pts) {\n        this.nextID();\n        SVGForm.polygon(this._ctx, pts);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        let bound = Group.fromArray(pts).boundingBox();\n        let size = Rectangle.size(bound);\n        DOMSpace.setAttr(elem, {\n            x: bound[0][0],\n            y: bound[0][1],\n            width: size[0],\n            height: size[1],\n            'class': `pts-svgform pts-rect ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        SVGForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = SVGSpace.svgElement(ctx.group, \"text\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            \"pointer-events\": \"none\",\n            x: pt[0],\n            y: pt[1],\n            dx: 0, dy: 0,\n            'class': `pts-svgform pts-text ${ctx.currentClass}`,\n        });\n        elem.textContent = txt;\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        SVGForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n}\nSVGForm.groupID = 0;\nSVGForm.domID = 0;\n//# sourceMappingURL=Svg.js.map","export * from \"./Canvas\";\nexport * from \"./Create\";\nexport * from \"./Form\";\nexport * from \"./LinearAlgebra\";\nexport * from \"./Num\";\nexport * from \"./Op\";\nexport * from \"./Pt\";\nexport * from \"./Space\";\nexport * from \"./Color\";\nexport * from \"./Util\";\nexport * from \"./Dom\";\nexport * from \"./Svg\";\nexport * from \"./Typography\";\nexport * from \"./Physics\";\nexport * from \"./UI\";\n//# sourceMappingURL=_module.js.map","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n"],"sourceRoot":""}